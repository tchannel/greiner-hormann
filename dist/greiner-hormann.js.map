{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "index.js",
    "lib/greiner-hormann.js",
    "lib/intersect.js",
    "lib/ring.js",
    "lib/subtract.js",
    "lib/union.js",
    "lib/util.js",
    "lib/vertex.js",
    "node_modules/geojson-equality/index.js",
    "node_modules/geojson-equality/node_modules/deep-equal/index.js",
    "node_modules/geojson-equality/node_modules/deep-equal/lib/is_arguments.js",
    "node_modules/geojson-equality/node_modules/deep-equal/lib/keys.js",
    "node_modules/turf-inside/index.js",
    "node_modules/turf-is-clockwise/index.js",
    "node_modules/turf-point/index.js",
    "node_modules/turf-polygon/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var intersect = require('./lib/intersect');\nvar union = require('./lib/union');\nvar utils = require('./lib/util');\n\n\nmodule.exports = {\n  union: union,\n  intersect: intersect,\n\n  // include utils to make things easier\n  utils: utils\n};\n",
    "// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html\nvar turfInside = require('turf-inside');\nvar turfPoint = require('turf-point');\nvar turfPolygon = require('turf-polygon');\nvar Ring = require('./ring');\nvar Vertex = require('./vertex');\nvar clockwise = require('turf-is-clockwise');\nvar equals = new (require('geojson-equality'));\n\n/**\n * Clips two polygons using Greiner-Hormann, with degeneracy handling\n *\n * - Greiner-Hormann: http://davis.wpi.edu/~matt/courses/clipping/\n * - Degeneracy handling: http://arxiv-web3.library.cornell.edu/pdf/1211.3376v1.pdf\n * - Python Polyclip: https://github.com/helderco/univ-polyclip\n * - ^ some Degeneracy handling: https://github.com/karimbahgat/Pure-Python-Greiner-Hormann-Polygon-Clipping/\n *\n * Some of the structure and logic is kidnapped from the python projects,\n * the remainder is derived from two papers\n */\nmodule.exports = function(subject, clipper, s_forward, c_forward) {\n  if (!clockwise(subject)) {\n    subject.reverse();\n  }\n\n  if (!clockwise(clipper)) {\n    clipper.reverse();\n  }\n\n  // Only build these once, since we might be checking them many times\n  try {\n    var sPoly = turfPolygon([subject]);\n    var cPoly = turfPolygon([clipper]);\n  } catch (err) {\n    console.log(\"Clipping error: bad polygons!\")\n    console.log(subject)\n    console.log(\"-------------------\")\n    console.log(clipper)\n  }\n\n  // These can be manipulated to change the output operation:\n  //\n  //  Operation        | s_forward   | c_forward\n  // -----------------------------------------------\n  //  Union            | false       | false\n  //  Intersect        | true        | true\n  //  Subtract (A - B) | false       | true\n  //  Subtract (B - A) | true        | false\n  //\n  s_forward = s_forward === false ? false : true;\n  c_forward = c_forward === false ? false : true;\n\n  // Greiner-Hormann clipping uses 3 phases:\n  //  1. Find intersection vertices, build data structure\n  //  2. Mark vertices as entry/exit points\n  //  3. Build Polygons\n  //\n  //  We additionally add in some special case handling\n  //  at the end, because GH won't handle cases where\n  //  one of the polygons fully encloses the other, or\n  //  the two polygons are totally disjoint\n  var sPoints = Ring.fromCoords(subject);\n  var cPoints = Ring.fromCoords(clipper);\n\n  /**\n   * PHASE ONE: Identify Intersections\n   */\n  var vertices = buildIntersectionLists(sPoints, cPoints, sPoly, cPoly);\n  markDegensAsIntersect(sPoints);\n\n\n  /**\n   * PHASE TWO: Identify Entry/Exit\n   */\n  // setEntryExit(sPoints, cPoints, s_forward, c_forward, sPoly, cPoly);\n  setEntryExit2(sPoints, cPoints, s_forward, c_forward, sPoints, cPoints);\n  logPoints(sPoints, cPoints);\n  /**\n   * PHASE THREE: Build clipped polys\n   */\n  var list = buildPolygons(sPoints);\n  console.log(list[0]);\n  return [[]];\n  return processPolygons(list, subject, clipper, sPoly, cPoly, s_forward, c_forward);\n}\n\n/**\n * Handles special cases depending on the clipping type.\n * As noted earlier, the s_forward and c_forward arguments\n * can be used to derive what the clipping operation is\n *\n * @param  {[type]} list      List of clipped polygons\n * @param  {[type]} subject   The subject coordinate list\n * @param  {[type]} clipper   The clipper coordinate list\n * @param  {[type]} sPoly     The subject as a geojson poly\n * @param  {[type]} cPoly     The clipper as a geojson poly\n * @param  {[type]} s_forward Whether the subject traversal is forward or backward\n * @param  {[type]} c_forward Whether the clipper traversal is forward or backward\n * @return {[type]}           [description]\n */\nfunction processPolygons(list, subject, clipper, sPoly, cPoly, s_forward, c_forward) {\n  if (list.length != 0) {\n    return list;\n  }\n  // Union Mode.\n  //\n  // - If the list is empty, the polys didn't intersect\n  // but should still be returned as a multipolygon\n  // - OR, the shapes are literally the same shape.\n  if (!s_forward && !c_forward) {\n    if (equals.compare(sPoly, cPoly)) {\n      return [[subject]];\n    }\n    return [[subject], [clipper]];\n  }\n\n  // Intersect Mode.\n  //\n  // - If the list is empty, either the polygons\n  // are disjoint, or they are literally the same polygon. So\n  // we'll check to for equality\n  if (s_forward && c_forward) {\n    if (equals.compare(sPoly, cPoly)) {\n      return [[subject]];\n    }\n  }\n\n  // Subtract Modes\n  if (s_forward ^ c_forward == 1) {\n    var testpt, testpoly, outer, hole;\n\n    if (!s_forward && c_forward) {\n      // Subtract A - B\n      testpt = turfPoint(clipper[0]);\n      testpoly = sPoly;\n      outer = subject;\n      hole = clipper;\n    } else {\n      // Subtract B - A\n      testpt = turfPoint(subject[0]);\n      testpoly = cPoly;\n      outer = clipper;\n      hole = subject;\n    }\n\n    var inside  = turfInside(testpt, testpoly);\n\n    // If the testpt is inside, then \"hole\" is *actually* a\n    // hole, so we should return the outer and the hole both\n    if (inside) {\n\n      return [[outer, hole]];\n    } else {\n      // IF the hole isn't inside the polygon, then\n      // there was no overlap, so outer - hole = outer\n      return [[outer]];\n    }\n  }\n}\n\n/**\n * Builds the list of Polygon(s) representing the desired overlap of\n * the subject/clipper.\n *\n * @param  {[type]} sPoints [description]\n * @return {[type]}         [description]\n */\nfunction buildPolygons(sPoints) {\n  var curr = sPoints.first;\n  var polylist = [];\n\n  while (curr = sPoints.firstIntersect()) {\n    var poly = [[curr.x, curr.y]];\n\n    do {\n      curr.checked = true;\n      if (curr.neighbor) {\n        curr.neighbor.checked = true;\n      }\n\n      if (curr.entry) {\n        do {\n            curr = curr.next;\n            if (!curr.intersect) {\n              poly.push([curr.x, curr.y]);\n            }\n\n        } while (!curr.intersect);\n      } else {\n        do {\n          curr = curr.prev;\n          if (!curr.intersect) {\n            poly.push([curr.x, curr.y]);\n          }\n\n        } while (!curr.intersect);\n      }\n\n      // Jump to the other list\n      curr = curr.neighbor\n    } while (!curr.checked);\n    //poly.push(poly[0])\n    polylist.push([poly])\n  }\n\n  return polylist;\n}\n\n/**\n * Builds vertex lists for the subject and clipper. Essentially\n * the way this will work is that it will detect intersections by\n * comparing each pair of lines between the subject / clipper, then\n * injecting intersection vertices (marked by the \"intersects\" property)\n * in the appropriate spots in each coordinate list.\n *\n * Once this is complete, our subject and clipper coordinate lists will\n * each contain, in traversable order, every vertex, including ones for\n * each point where the other polygon intersected.\n *\n * @param  {[type]} sPoints [description]\n * @param  {[type]} cPoints [description]\n * @return {[type]}         [description]\n */\nfunction buildIntersectionLists(sPoints, cPoints, sPoly, cPoly) {\n  var sCurr = sPoints.first;\n\n  do {\n    setPointRelativeLocation(sCurr, cPoly)\n    var cCurr = cPoints.first;\n    if (!sCurr.intersect) {\n      do {\n        setPointRelativeLocation(cCurr, sPoly)\n        if (!cCurr.intersect) {\n          var sEnd = sPoints.nextNonIntersect(sCurr.next);\n          var cEnd = cPoints.nextNonIntersect(cCurr.next);\n          var intersect = lineIntersects(sCurr, sEnd, cCurr, cEnd);\n\n          if (intersect) {\n            cCurr = handleIntersection(sPoints, cPoints, sCurr, sEnd, cCurr, cEnd, intersect);\n          }\n        }\n\n        cCurr = cCurr.next;\n      } while (cCurr != cPoints.first);\n    }\n\n    sCurr = sCurr.next;\n  } while (sCurr != sPoints.first);\n}\n\n/**\n * Loop back through, ensuring that all degenerate vertices\n * are marked as intersections.\n *\n * @param  {Ring} points [description]\n * @return {[type]}        [description]\n */\nfunction markDegensAsIntersect(points) {\n  var curr = points.first;\n\n  do {\n    if (curr.degenerate) {\n      curr.intersect = true;\n      curr.neighbor.intersect = true;\n    }\n    curr = curr.next\n  } while (curr != points.first)\n}\n\n/**\n * Handle inserting / replacing points appropriately for\n * a found intersection\n *\n * @param  {Ring}   sPoints   Subject Ring\n * @param  {Ring}   cPoints   Clip Ring\n * @param  {Vertex} sCurr     Start of the Subject line\n * @param  {Vertex} sEnd      End of the Subject line\n * @param  {Vertex} cCurr     Start of the Clip line\n * @param  {Vertex} cEnd      End of the Clip line\n * @param  {Object} intersect Object representing an intersection\n * @return {[type]}           [description]\n */\nfunction handleIntersection(sPoints, cPoints, sCurr, sEnd, cCurr, cEnd, intersect) {\n  var sPt, cPt;\n  var s_between = 0 < intersect.alphaA && intersect.alphaA < 1;\n  var c_between = 0 < intersect.alphaB && intersect.alphaB < 1;\n\n  if (s_between && c_between) {\n    sPt = new Vertex(intersect.x, intersect.y, intersect.alphaA, true);\n    cPt = new Vertex(intersect.x, intersect.y, intersect.alphaB, true);\n    sPoints.insert(sPt, sCurr, sEnd);\n    cPoints.insert(cPt, cCurr, cEnd);\n  } else {\n    // Handle various degeneracy cases for the subject point\n    if (s_between) {\n      sPt = new Vertex(intersect.x, intersect.y, intersect.alphaA, true, true);\n      sPoints.insert(sPt, sCurr, sPoints.nextNonIntersect(sCurr.next));\n    } else if (intersect.alphaA == 0) {\n      sCurr.intersect = true;\n      sCurr.degenerate = true;\n      sCurr.alpha = intersect.alphaA;\n      sPt = sCurr;\n    } else if (intersect.alphaA == 1) {\n      // End points get marked as degenerate but don't get marked as intersects.\n      // This allows us to catch them later, and still use them for generating\n      // lines to test against the other polygon\n      sEnd.intersect = false;\n      sEnd.degenerate = true;\n      sEnd.alpha = intersect.alphaA;\n      sPt = sEnd;\n    }\n\n    // Handle various degeneracy cases for the clip point\n    if (c_between) {\n      cPt = new Vertex(intersect.x, intersect.y, intersect.alphaB, true, true);\n      cPoints.insert(cPt, cCurr, cPoints.nextNonIntersect(cCurr.next));\n    } else if (intersect.alphaB == 0) {\n      cCurr.intersect = true;\n      cCurr.degenerate = true;\n      cCurr.alpha = intersect.alphaB;\n      cPt = cCurr;\n    } else if (intersect.alphaB == 1) {\n      // End points get marked as degenerate but don't get marked as intersects.\n      // This allows us to catch them later, and still use them for generating\n      // lines to test against the other polygon\n      cEnd.intersect = false;\n      cEnd.degenerate = true;\n      cEnd.alpha = intersect.alphaB;\n      cPt = cEnd;\n      if (cCurr.next != cPoints.first) {\n        cCurr = cCurr.next;\n      }\n    }\n  }\n\n  // Neighbors are used to jump back and forth between the lists\n  if (sPt && cPt) {\n    sPt.neighbor = cPt;\n    cPt.neighbor = sPt;\n    // Intersections are always \"on\" a line\n    sPt.type = \"on\";\n    cPt.type = \"on\";\n  }\n  return cCurr;\n}\n\n/**\n * Set a point in or out compared to the other polygon:\n * - if it's a subject point, compare to the clip polygon,\n * - if it's a clip point, compare to the subject polygon\n *\n * @param {Vertex}  pt   Point to check against the poly\n * @param {Polygon} poly Check if pt is within this poly\n */\nfunction setPointRelativeLocation(pt, poly) {\n  if (!pt.type) {\n    if (turfInside(turfPoint([pt.x, pt.y]), poly)) {\n      pt.type = \"in\";\n    } else {\n      pt.type = \"out\";\n    }\n  }\n}\n\n/**\n * Handle setting entry/exit flags for each intersection. This is\n * where a large part of degeneracy handling happens - the original\n * GH algorithm uses very simple entry/exit handling, which won't work\n * for our degenerate cases.\n *\n * http://arxiv-web3.library.cornell.edu/pdf/1211.3376v1.pdf\n *\n * @param {Ring}    list     [description]\n * @param {boolean} sForward [description]\n * @param {boolean} cForward [description]\n * @param {Polygon} sPoly    [description]\n * @param {Polygon} cPoly    [description]\n */\nfunction setEntryExit(list, list2, s_forward, c_forward, sPoly, cPoly) {\n  var curr = list.first;\n  var sForward = s_forward;\n  var cForward = c_forward;\n\n  do {\n    if (curr.intersect) {\n      var remove = (curr.areTypesEqual() && curr.neighbor.areTypesEqual());\n      handleEntryAndType(curr, sForward, cForward, remove);\n      handleEntryAndType(curr.neighbor, cForward, sForward, remove);\n      if (remove) curr.removeCond = \"Doubled\"\n\n      if (!remove && curr.entryIs(!sForward, !cForward)) {\n        c\n        curr.removeCond = \"No Double, both nonentry\"\n        remove = true;\n        curr.type = 'out';\n        curr.neighbor.type = 'out';\n      } else if (!remove && curr.entryIs(sForward, cForward)) {\n        curr.removeCond = \"No Double, both entry\";\n        remove = true;\n        curr.type = 'in';\n        curr.neighbor.type = 'in';\n      }\n      if (remove) {\n        curr.intersect = false;\n        curr.neighbor.intersect = false;\n      }\n    }\n    curr = curr.next;\n  } while (curr != list.first);\n}\n\n\nfunction setEntryExit2(sPoints, cPoints, sForward, cForward, sPoly, cPoly)\n{\n  var first = sPoints.first;\n  var curr = first;\n\n  do {\n    handleEnEx(curr);\n    if (curr.neighbor) {\n      handleEnEx(curr.neighbor);\n      console.log(curr.entryPair());\n      switch (curr.entryPair()) {\n        case \"en/en\":\n          curr.remove = true;\n          curr.type = \"in\";\n          break;\n        case \"ex/ex\":\n          curr.remove = true;\n          curr.type = \"out\";\n          break;\n      }\n    }\n\n    curr = curr.next;\n  } while (curr != first)\n}\n\n\nfunction handleEnEx(curr)\n{\n  switch (curr.pairing()) {\n      case \"in/out\":\n      case \"on/out\":\n      case \"in/on\":\n        curr.entry = false;\n        break;\n      case \"out/in\":\n      case \"on/in\":\n      case \"out/on\":\n        curr.entry = true;\n        break;\n      case \"out/out\":\n      case \"in/in\":\n      case \"on/on\":\n        var np = curr.neighbor.pairing();\n        if (np == \"out/out\" || np == \"in/in\" || np == \"on/on\") {\n          curr.remove = true;\n        } else {\n          handleEnEx(curr.neighbor);\n          curr.entry = !curr.neighbor.entry;\n        }\n        break;\n    }\n}\n\n\n/**\n * Handles setting the entry/exit flag as well as readjusting the \"type\"\n * flag for a given vertex, given it's neighbors. This is part of the\n * GH degeneracy handling.\n *\n * @param  {Vertex}  curr   The vertex to flag\n * @param  {boolean} entry  Vertex entry flag\n * @param  {boolean} nEntry Neighbor entry flags\n * @param  {boolean} remove Whether we've detected that this Vertex should be\n *                          removed from the intersections list\n * @return {[type]}\n */\nfunction handleEntryAndType(curr, entry, nEntry, remove) {\n  if (curr.typeIs('on', 'on')) {\n    if (!curr.neighbor.typeIs('on', 'on')) {\n      handleEntryAndType(curr.neighbor, nEntry, entry, remove);\n      if (entry == nEntry) {\n        curr.entry = !curr.neighbor.entry\n      } else {\n        curr.entry = curr.neighbor.entry\n      }\n\n      if (remove) {\n        if (curr.neighbor.type == 'in') {\n          curr.type = 'out';\n        } else {\n          curr.type = 'in';\n        }\n      }\n    } else {\n      curr.type = 'in';\n    }\n  } else if (curr.typeIs('out', 'out') && remove) {\n    curr.type = 'out';\n  } else if (curr.typeIs('in', 'in') && remove) {\n    curr.type = 'in';\n  } else if (curr.typeIs('on', 'out') || curr.typeIs('in', 'on') || curr.typeIs('in', 'out')) {\n    curr.entry = !entry;\n  } else if (curr.typeIs('on', 'in') || curr.typeIs('out', 'on') || curr.typeIs('out', 'in')) {\n    curr.entry = entry;\n  }\n}\n\n\n/**\n * Take two lines (each represented by the respective\n * start and end), and tells you where they intersect,\n * as well as the intersection alphas\n *\n * @param  {Vertex} start1 [description]\n * @param  {Vertex} end1   [description]\n * @param  {Vertex} start2 [description]\n * @param  {Vertex} end2   [description]\n * @return {[type]}        [description]\n */\nfunction lineIntersects(start1, end1, start2, end2) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, numerator1, numerator2, result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false,\n    alphaA: null,\n    alphaB: null,\n  };\n  denominator = ((end2.y - start2.y) * (end1.x - start1.x)) - ((end2.x - start2.x) * (end1.y - start1.y));\n  if (denominator == 0) {\n    if (start1.equals(start2)) {\n      result.x = start1.x\n      result.y = start1.y\n      result.alphaA = 0;\n      result.alphaB = 0;\n      return result;\n    }\n    return false;\n  }\n\n  a = start1.y - start2.y;\n  b = start1.x - start2.x;\n  numerator1 = ((end2.x - start2.x) * a) - ((end2.y - start2.y) * b);\n  numerator2 = ((end1.x - start1.x) * a) - ((end1.y - start1.y) * b);\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  // if we cast these lines infinitely in both directions, they intersect here:\n  result.x = start1.x + (a * (end1.x - start1.x));\n  result.y = start1.y + (a * (end1.y - start1.y));\n  result.alphaA = a;\n  result.alphaB = b;\n\n  // TODO: any better way to handle this?\n  if (result.alphaA > 0.99999999999999) {\n    result.alphaA = 1;\n  }\n  if (result.alphaB > 0.99999999999999) {\n    result.alphaB = 1;\n  }\n  if (result.alphaA < 0.00000000000001) {\n    result.alphaA = 0;\n  }\n  if (result.alphaB < 0.00000000000001) {\n    result.alphaB = 0;\n  }\n\n  // if line1 is a segment and line2 is infinite, they intersect if:\n  if (0 <= a && a <= 1) {\n    result.onLine1 = true;\n  }\n  // if line2 is a segment and line1 is infinite, they intersect if:\n  if (0 <= b && b <= 1) {\n    result.onLine2 = true;\n  }\n  // if line1 and line2 are segments, they intersect if both of the above are true\n  if(result.onLine1 && result.onLine2){\n    return result;\n  }\n  else {\n    return false;\n  }\n}\n\n\n// Log all points\nfunction logPoints(sPoints, cPoints) {\n  var curr = sPoints.first\n  do {\n    logPoint(curr);\n    curr = curr.next\n  } while (curr != sPoints.first)\n  console.log(\"-----------------\")\n  if (!cPoints) return;\n  var curr = cPoints.first\n  do {\n    logPoint(curr);\n    curr = curr.next\n  } while (curr != cPoints.first)\n}\n\n// Log only intersections (or degeneracies that used to be intersections)\nfunction logIntersections(sPoints) {\n  console.log(\"-------------------\")\n  console.log(\"INTERSECTION LIST: \")\n  console.log(\"-------------------\")\n  var curr = sPoints.first\n  do {\n    if (curr.intersect || curr.degenerate) {\n      logPoint(curr);\n    }\n    curr = curr.next\n  } while (curr != sPoints.first)\n  console.log(\"\")\n}\n\n// Log a point\nfunction logPoint(curr) {\n  console.log(curr.x + \", \"+curr.y\n      +\" INTERSECT: \"+ (curr.intersect ? \"Yes\" : \"No \")\n      +\" ENTRY: \"+(curr.entry ? \"Yes\": \"No \")\n      +\" DEGEN: \"+(curr.degenerate ? \"Yes\": \"No \")\n      +\" TYPE: \"+String(curr.prev.type+\" \").slice(0, 3)\n          +\" / \"+String(curr.type+\" \").slice(0, 3)\n          +\" / \"+String(curr.next.type+\" \").slice(0, 3)\n      +\" ALPHA: \"+curr.alpha\n      +\" REMOVE: \"+ (curr.remove ? \"Yes\": \"No\") + \" \"\n      +\" DOUBLE: \"+ curr.removeCond\n\n    );\n}\n",
    "var ghClipping = require('./greiner-hormann');\nvar turfInside = require('turf-inside');\nvar turfPoint = require('turf-point');\nvar turfPolygon = require('turf-polygon');\nvar union = require('./union');\nvar utils = require('./util');\nvar subtract = require('./subtract');\n\nmodule.exports = function(subject, clipper) {\n  var subject = utils.clone(subject);\n  var clipper = utils.clone(clipper);\n  var hulls = utils.outerHulls(subject).concat(utils.outerHulls(clipper));\n  var holes = utils.holes(subject).concat(utils.holes(clipper));\n  var result = [];\n\n  // Intersect all hulls\n  for (var i = 0; i < hulls.length; i++) {\n    for (var j = i+1; j < hulls.length; j++) {\n      var test = ghClipping(hulls[i], hulls[j], true, true);\n      if (Array.isArray(test)) {\n        result = result.concat(test);\n      }\n    }\n  }\n\n  // Union all the holes then subtract them rom the result\n  if (holes.length > 0) {\n    var holeUnion = union(holes);\n    return subtract(result, utils.outerHulls(holeUnion));\n  }\n\n  return result;\n}\n",
    "Vertex = require('./vertex');\n/**\n * Ring is a *circular* doubly-linked list; Every node\n * has a next and a prev, even if it's the only node in the list.\n *\n * This supports some search methods that need to wrap back to the start of the list.\n */\nfunction Ring () {\n    this.first = null;\n}\n\n/**\n * Takes an array of coordinates and constructs a Ring\n *\n * @param  {array} coordinates [description]\n * @return {Ring}             [description]\n */\nRing.fromCoords = function(coordinates) {\n    var ring = new Ring()\n\n    for (var i = 0; i < (coordinates.length - 1); i++) {\n        var elem = coordinates[i];\n        ring.push(new Vertex(elem[0], elem[1]));\n    }\n\n    return ring;\n}\n\n/**\n * Push a vertex into the ring's list. This\n * just updates pointers to put the point at\n * the end of the list\n *\n * @param  {Vertex} vertex [description]\n * @return {[type]}        [description]\n */\nRing.prototype.push = function(vertex) {\n    if (!this.first) {\n        this.first = vertex;\n        this.first.prev = vertex;\n        this.first.next = vertex;\n    } else {\n        next = this.first;\n        prev = next.prev;\n        next.prev = vertex;\n        vertex.next = next;\n        vertex.prev = prev;\n        prev.next = vertex;\n    }\n}\n\n/**\n * Insert a vertex between specific vertices\n *\n * If there are intersection points, inbetween\n * start and end, the new vertex is inserted\n * based on it's alpha value\n *\n * @param  {Vertex} vertex [description]\n * @param  {Vertex} start  [description]\n * @param  {Vertex} end    [description]\n * @return {[type]}        [description]\n */\nRing.prototype.insert = function(vertex, start, end) {\n    var curr = start.next;\n\n    while (curr != end && curr.alpha < vertex.alpha) {\n        curr = curr.next;\n    }\n\n    // Insert just before the \"curr\" value\n    vertex.next = curr;\n    prev = curr.prev;\n    vertex.prev = prev;\n    prev.next = vertex;\n    curr.prev = vertex;\n}\n\n/**\n * Start at the start vertx, and get the next\n * point that *isn't* an intersection\n *\n * @param  {Vertex} start [description]\n * @return {Vertex}       [description]\n */\nRing.prototype.nextNonIntersect = function (start) {\n    var curr = start;\n    while (curr.intersect && curr != this.first && curr.next != this.first) {\n        curr = curr.next\n    }\n    return curr;\n}\n\n/**\n * Returns the first unchecked intersection in the list\n *\n * @return {[type]} [description]\n */\nRing.prototype.firstIntersect = function () {\n    var curr =  this.first;\n\n    while (true) {\n        if (curr.intersect && !curr.checked) {\n            return curr;\n        }\n\n        curr = curr.next;\n\n        if (curr == this.first) {\n            break;\n        }\n    }\n    return false;\n}\n\nRing.prototype.toArray = function () {\n    var curr = this.first;\n    var points = [];\n\n    do {\n        points.push([curr.x, curr.y]);\n        curr = curr.next;\n    } while (curr != this.first);\n\n    return points;\n}\n\nmodule.exports = Ring;\n",
    "var util = require('./util');\nvar ghClipping = require('./greiner-hormann');\n\nmodule.exports = function(subject, clip) {\n  subject = util.clone(subject);\n  clip = util.clone(clip);\n\n  // TODO:\n  // Subtract each outer hull of the clip from the subject\n  // If there are any holes in the subject, subtract those as well\n  // If there are any holes in the clip, which overlap the original\n  // subject, these should be unioned in. This means we'll have to\n  // check polygon within-ness for each clip hole\n\n  // Next we'll subtract each hole from each intersection polygon.\n  for (var i = 0; i < clip.length; i++) {\n    var ilen = subject.length;\n    for (var j = 0; j < subject.length; j++) {\n      var test = ghClipping(subject[j][0], clip[i], false, true);\n\n      // Copy the primary hull of the intersect record that\n      // we just clipped against the hull\n      subject[j][0] = test[0][0];\n\n      // Copy in each hole (if there were any) for the primary hull\n      for (var k = 1; k < test[0].length; k++) {\n        subject[j].push(test[0][k]);\n      }\n\n      // If there are any additional polygons in the result,\n      // they were newly created by intersecting this hole.\n      // Push the new polygon (hull and any holes) straight\n      // into the intersect list\n      for (var k = 1; k < test.length; k++) {\n        subject.push(test[k]);\n      }\n    }\n\n    // If the length has changed, this hole created\n    // new intersection polygons, which means it's not a hole\n    // anymore (it crossed the polys, now it's boundary is\n    // part of the new intersection hulls). Therefore, we\n    // remove this hole from the list so it won't be returned.\n    if (ilen != subject.length) {\n      clip.splice(i, 1)\n      i--;\n    }\n  }\n\n  return subject;\n}\n",
    "var ghClipping = require('./greiner-hormann');\nvar utils = require('./util');\nvar subtract = require('./subtract');\n\n/**\n * Iteratively join all rings in the passed set.\n *\n * @param  {array} rings An array of polygon rings\n * @return {[type]}       [description]\n */\nfunction unionRings(rings)\n{\n  for (var i = 0; i < rings.length; i++) {\n    for (var j = i+1; j < rings.length; j++) {\n      if (i == j) {\n        continue;\n      }\n      var test = utils.outerHulls(ghClipping(rings[i], rings[j], false, false));\n\n      // If the length is 1, we joined the two areas, so replace\n      // rings[i] with the new shape, and remove rings[j]\n      // Then reset the j iterator so we can make sure that none of\n      // the previous rings will now overlap the new rings[i]\n      if (test.length == 1) {\n        rings[i] = test[0];\n        rings.splice(j, 1);\n        j = i;\n      }\n    }\n  }\n  return rings;\n}\n\n// TODO: make this support polys + holes. Right now\n// it takes an array of rings, not array of polys.\n//\n// TODO: think about the function signature here? Should it be\n// traditional \"union A + B\", or is passing a set of things to union more useful\n//\n// TODO: think about using the approach here: http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html\n// to make things faster for complex / very degenerate sets\nmodule.exports = function(coords, coords2) {\n  if (typeof coords2 != 'undefined' && coords2 != null) {\n    // TODO: make this more robust. This will fail in some cases\n    if (!utils.isMultiPolygon(coords)) {\n      coords = [coords];\n    }\n    if (!utils.isMultiPolygon(coords2)) {\n      coords2 = [coords2];\n    }\n    coords = coords.concat(coords2)\n  }\n\n\n  coords = utils.clone(coords);\n  var hulls = utils.outerHulls(coords);\n  var holes = utils.holes(coords);\n\n  // Union all hulls\n  hulls = utils.wrapToPolygons(unionRings(hulls));\n\n  // Union all holes - If holes overlap, they should be joined\n  if (holes.length > 0) {\n    holes = unionRings(holes);\n\n    // Subtract all rings from the unioned set\n    return subtract(hulls, holes);\n  }\n\n  return hulls;\n}\n",
    "if (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n\n// deep clone an array of coordinates / polygons\nexports.clone = function(array) {\n  var new_arr = [];\n  for (var i = 0; i < array.length; i++) {\n    if (Array.isArray(array[i])){\n      new_arr.push(exports.clone(array[i]).slice());\n    } else {\n      new_arr.push(array[i]);\n    }\n  }\n  return new_arr;\n}\n\n// Wrap an array of geometries to an array of polygons\nexports.wrapToPolygons = function(array) {\n  var wrapped = [];\n  for(var i = 0; i < array.length; i++) {\n    if (exports.isRing(array[i])) {\n      wrapped.push([array[i]]);\n    } else if (exports.isMultiPolygon(array[i])) {\n      wrapped.concat(array[i]);\n    } else if (exports.isPolygon(array[i])) {\n      wrapped.push(array[i]);\n    }\n  }\n  return wrapped;\n}\n\n// Unwrap polygons to an array of rings\nexports.unwrap = function(array) {\n  var unwrapped = [];\n  for (var i = 0; i < array.length; i++) {\n    for (var j = 0; j < array[i].length; j++) {\n      unwrapped.push(array[i][j]);\n    }\n  }\n}\n\n\n/**\n * Count array depth (used to check for geom type)\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.depth = function(collection) {\n  function depth(collection, num) {\n    if (Array.isArray(collection)) {\n      return depth(collection[0], num+1);\n    }\n    return num;\n  }\n\n  return depth(collection, 0);\n}\n\n\nexports.isMultiPolygon = function(poly) {\n  if (exports.depth(poly) == 4) {\n    return true;\n  }\n  return false;\n}\n\n\nexports.isPolygon = function(poly) {\n  if (exports.depth(poly) == 3) {\n    return true;\n  }\n  return false;\n}\n\nexports.isRing = function(poly) {\n  if(exports.depth(poly) == 2) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Takes a list of polygons / multipolygons and returns only the outer hulls\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.outerHulls = function(collection) {\n  var hulls = [];\n\n  for (var i = 0; i < collection.length; i++) {\n    if (exports.isMultiPolygon(collection[i])) {\n      // Each polygon\n      for (var j = 0; j < collection[i].length; j++) {\n        hulls.push(collection[i][j][0]);\n      }\n    } else if (exports.isPolygon(collection[i])) {\n      hulls.push(collection[i][0]);\n    } else if (exports.isRing(collection[i])) {\n      hulls.push(collection[i]);\n    }\n  }\n\n  return hulls;\n}\n\n/**\n * Takes a list of multipolygons / polygons and returns only the holes\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.holes = function(collection) {\n  var holes = [];\n\n  for (var i = 0; i < collection.length; i++) {\n    if (exports.isMultiPolygon(collection[i])) {\n      // Each polygon\n      for (var j = 0; j < collection[i].length; j++) {\n        for (var k = 1; k < collection[i][j].length; k++) {\n          holes.push(collection[i][j][k]);\n        }\n      }\n    } else if (exports.isPolygon(collection[i])) {\n      for (var j = 1; j < collection[i].length; j++) {\n        holes.push(collection[i][j]);\n      }\n    }\n  }\n\n  return holes;\n}\n",
    "function Vertex (x, y, alpha, intersect, degenerate) {\n    this.x = x;\n    this.y = y;\n    this.alpha = alpha || 0.0;\n    this.intersect = intersect || false;\n    this.entry = true; // Set to true by default, for degeneracy handling\n    this.checked = false;\n    this.degenerate = degenerate || false;\n    this.neighbor = null;\n    this.next = null;\n    this.prev = null;\n    this.type = null; // can be \"in\", \"out\", \"on\"\n    this.justMarked = false;\n    this.remove = false;\n}\n\nVertex.prototype.pairing = function () {\n    return this.prev.type + \"/\" + this.next.type;\n}\n\nVertex.prototype.entryPair = function() {\n    var entry = this.entry ? \"en\" : \"ex\";\n    var nEntry = this.neighbor.entry ? \"en\" : \"ex\";\n\n    return entry+\"/\"+nEntry;\n}\n\n\nVertex.prototype.equals = function(other) {\n    if (this.x == other.x && this.y == other.y) {\n        return true;\n    }\n    return false;\n};\n\nVertex.prototype.typeIs = function(p, n) {\n    if (this.prev.type == p && this.next.type == n) {\n        return true;\n    }\n    return false;\n};\n\nVertex.prototype.areTypesEqual = function () {\n    if (this.typeIs('on', 'on') || this.typeIs('out', 'out') || this.typeIs('in','in')) {\n        return true;\n    }\n    return false;\n}\n\n\nVertex.prototype.entryIs = function(curr, neighbor) {\n    if (this.entry == curr && this.neighbor.entry == neighbor) {\n        return true;\n    }\n    return false;\n}\n\nmodule.exports = Vertex;\n",
    "//index.js\nvar deepEqual = require('deep-equal');\n\nvar Equality = function(opt) {\n  this.precision = opt && opt.precision ? opt.precision : 17;\n  this.direction = opt && opt.direction ? opt.direction : false;\n  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;\n  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;\n};\n\nEquality.prototype.compare = function(g1,g2) {\n  if (g1.type !== g2.type || !sameLength(g1,g2)) return false;\n\n  switch(g1.type) {\n  case 'Point':\n    return this.compareCoord(g1.coordinates, g2.coordinates);\n    break;\n  case 'LineString':\n    return this.compareLine(g1.coordinates, g2.coordinates,0,false);\n    break;\n  case 'Polygon':\n    return this.comparePolygon(g1,g2);\n    break;\n  case 'Feature':\n    return this.compareFeature(g1, g2);\n  default:\n    if (g1.type.indexOf('Multi') === 0) {\n      var context = this;\n      var g1s = explode(g1);\n      var g2s = explode(g2);\n      return g1s.every(function(g1part) {\n        return this.some(function(g2part) {\n          return context.compare(g1part,g2part);\n        });\n      },g2s);\n    }\n  }\n  return false;\n};\n\nfunction explode(g) {\n  return g.coordinates.map(function(part) {\n    return {\n      type: g.type.replace('Multi', ''),\n      coordinates: part}\n  });\n}\n//compare length of coordinates/array\nfunction sameLength(g1,g2) {\n   return g1.hasOwnProperty('coordinates') ?\n    g1.coordinates.length === g2.coordinates.length\n    : g1.length === g2.length;\n}\n\n// compare the two coordinates [x,y]\nEquality.prototype.compareCoord = function(c1,c2) {\n  return c1[0].toFixed(this.precision) === c2[0].toFixed(this.precision)\n    && c1[1].toFixed(this.precision) === c2[1].toFixed(this.precision);\n};\n\nEquality.prototype.compareLine = function(path1,path2,ind,isPoly) {\n  if (!sameLength(path1,path2)) return false;\n  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);\n  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);\n  if (isPoly && !this.compareCoord(p1[0],p2[0])) {\n    // fix start index of both to same point\n    p2 = this.fixStartIndex(p2,p1);\n    if(!p2) return;\n  }\n  // for linestring ind =0 and for polygon ind =1\n  var sameDirection = this.compareCoord(p1[ind],p2[ind]);\n  if (this.direction || sameDirection\n  ) {\n    return this.comparePath(p1, p2);\n  } else {\n    if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])\n    ) {\n      return this.comparePath(p1.slice().reverse(), p2);\n    }\n    return false;\n  }\n};\nEquality.prototype.fixStartIndex = function(sourcePath,targetPath) {\n  //make sourcePath first point same as of targetPath\n  var correctPath,ind = -1;\n  for (var i=0; i< sourcePath.length; i++) {\n    if(this.compareCoord(sourcePath[i],targetPath[0])) {\n      ind = i;\n      break;\n    }\n  }\n  if (ind >= 0) {\n    correctPath = [].concat(\n      sourcePath.slice(ind,sourcePath.length),\n      sourcePath.slice(1,ind+1));\n  }\n  return correctPath;\n};\nEquality.prototype.comparePath = function (p1,p2) {\n  var cont = this;\n  return p1.every(function(c,i) {\n    return cont.compareCoord(c,this[i]);\n  },p2);\n};\n\nEquality.prototype.comparePolygon = function(g1,g2) {\n  if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {\n    var holes1 = g1.coordinates.slice(1,g1.coordinates.length);\n    var holes2 = g2.coordinates.slice(1,g2.coordinates.length);\n    var cont = this;\n    return holes1.every(function(h1) {\n      return this.some(function(h2) {\n        return cont.compareLine(h1,h2,1,true);\n      });\n    },holes2);\n  } else {\n    return false;\n  }\n};\n\nEquality.prototype.compareFeature = function(g1,g2) {\n  if (\n    g1.id !== g2.id ||\n    !this.objectComparator(g1.properties, g2.properties)\n  ) {\n    return false;\n  }\n\n  return this.compare(g1.geometry, g2.geometry);\n};\n\nEquality.prototype.removePseudo = function(path) {\n  //TODO to be implement\n  return path;\n};\n\nfunction objectComparator(obj1, obj2) {\n  return deepEqual(obj1, obj2, {strict: true});\n}\n\nmodule.exports = Equality;\n",
    "var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n",
    "var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n",
    "exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n",
    "// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} feature and a {@link Polygon} feature and determines if the Point resides inside the Polygon. The Polygon can\n * be convex or concave. The function accepts any valid Polygon or {@link MultiPolygon}\n * and accounts for holes.\n *\n * @module turf/inside\n * @category joins\n * @param {Point} point a Point feature\n * @param {Polygon} polygon a Polygon feature\n * @return {Boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt1 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#f00\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-111.467285, 40.75766]\n *   }\n * };\n * var pt2 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#0f0\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-111.873779, 40.647303]\n *   }\n * };\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [-112.074279, 40.52215],\n *       [-112.074279, 40.853293],\n *       [-111.610107, 40.853293],\n *       [-111.610107, 40.52215],\n *       [-112.074279, 40.52215]\n *     ]]\n *   }\n * };\n *\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [pt1, pt2, poly]\n * };\n *\n * //=features\n *\n * var isInside1 = turf.inside(pt1, poly);\n * //=isInside1\n *\n * var isInside2 = turf.inside(pt2, poly);\n * //=isInside2\n */\nmodule.exports = function(point, polygon) {\n  var polys = polygon.geometry.coordinates;\n  var pt = [point.geometry.coordinates[0], point.geometry.coordinates[1]];\n  // normalize to multipolygon\n  if(polygon.geometry.type === 'Polygon') polys = [polys];\n\n  var insidePoly = false;\n  var i = 0;\n  while (i < polys.length && !insidePoly) {\n    // check if it is in the outer ring first\n    if(inRing(pt, polys[i][0])) {\n      var inHole = false;\n      var k = 1;\n      // check for the point in any of the holes\n      while(k < polys[i].length && !inHole) {\n        if(inRing(pt, polys[i][k])) {\n          inHole = true;\n        }\n        k++;\n      }\n      if(!inHole) insidePoly = true;\n    }\n    i++;\n  }\n  return insidePoly;\n}\n\n// pt is [x,y] and ring is [[x,y], [x,y],..]\nfunction inRing (pt, ring) {\n  var isInside = false;\n  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n    var xi = ring[i][0], yi = ring[i][1];\n    var xj = ring[j][0], yj = ring[j][1];\n    \n    var intersect = ((yi > pt[1]) != (yj > pt[1]))\n        && (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n    if (intersect) isInside = !isInside;\n  }\n  return isInside;\n}\n\n",
    "module.exports = function(ring){\n  var sum = 0;\n  var i = 1;\n  var len = ring.length;\n  var prev,cur;\n  while(i<len){\n    prev = cur||ring[0];\n    cur = ring[i];\n    sum += ((cur[0]-prev[0])*(cur[1]+prev[1]));\n    i++;\n  }\n  return sum > 0;\n}",
    "/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @module turf/point\n * @category helper\n * @param {number} longitude position west to east in decimal degrees\n * @param {number} latitude position south to north in decimal degrees\n * @param {Object} properties an Object that is used as the {@link Feature}'s\n * properties\n * @return {Point} a Point feature\n * @example\n * var pt1 = turf.point([-75.343, 39.984]);\n *\n * //=pt1\n */\nvar isArray = Array.isArray || function(arg) {\n  return Object.prototype.toString.call(arg) === '[object Array]';\n};\nmodule.exports = function(coordinates, properties) {\n  if (!isArray(coordinates)) throw new Error('Coordinates must be an array');\n  if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"Point\",\n      coordinates: coordinates\n    },\n    properties: properties || {}\n  };\n};\n",
    "/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a GeoJSON {@link Polygon} feature.\n *\n * @module turf/polygon\n * @category helper\n * @param {Array<Array<Number>>} rings an array of LinearRings\n * @param {Object} properties an optional properties object\n * @return {Polygon} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the\n * beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *  [-2.275543, 53.464547],\n *  [-2.275543, 53.489271],\n *  [-2.215118, 53.489271],\n *  [-2.215118, 53.464547],\n *  [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nmodule.exports = function(coordinates, properties){\n\n  if (coordinates === null) throw new Error('No coordinates passed');\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var ring = coordinates[i];\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring.length < 4) {\n        throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n      }\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error('First and last Position are not equivalent.');\n      }\n    }\n  }\n\n  var polygon = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n      \"type\": \"Polygon\",\n      \"coordinates\": coordinates\n    },\n    \"properties\": properties\n  };\n\n  if (!polygon.properties) {\n    polygon.properties = {};\n  }\n\n  return polygon;\n};\n"
  ]
}