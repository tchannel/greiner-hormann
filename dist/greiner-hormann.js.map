{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "index.js",
    "lib/greiner-hormann.js",
    "lib/intersect.js",
    "lib/ring.js",
    "lib/subtract.js",
    "lib/union.js",
    "lib/util.js",
    "lib/vertex.js",
    "node_modules/turf-inside/index.js",
    "node_modules/turf-is-clockwise/index.js",
    "node_modules/turf-point/index.js",
    "node_modules/turf-polygon/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var intersect = require('./lib/intersect');\nvar union = require('./lib/union');\nvar utils = require('./lib/util');\n\n\nmodule.exports = {\n  union: union,\n  intersect: intersect,\n\n  // include utils to make things easier\n  utils: utils\n};\n",
    "// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html\nvar turfInside = require('turf-inside');\nvar turfPoint = require('turf-point');\nvar turfPolygon = require('turf-polygon');\nvar Ring = require('./ring');\nvar Vertex = require('./vertex');\nvar clockwise = require('turf-is-clockwise');\n\n/**\n * Clips two polygons using Greiner-Hormann, with degeneracy handling\n *\n * - Greiner-Hormann: http://davis.wpi.edu/~matt/courses/clipping/\n * - Degeneracy handling: http://arxiv-web3.library.cornell.edu/pdf/1211.3376v1.pdf\n * - Python Polyclip: https://github.com/helderco/univ-polyclip\n * - ^ some Degeneracy handling: https://github.com/karimbahgat/Pure-Python-Greiner-Hormann-Polygon-Clipping/\n *\n * Some of the structure and logic is kidnapped from the python projects,\n * the remainder is derived from two papers\n */\nmodule.exports = function(subject, clipper, s_forward, c_forward) {\n  var mode;\n\n  if (!clockwise(subject)) {\n    subject.reverse();\n  }\n\n  if (!clockwise(clipper)) {\n    clipper.reverse();\n  }\n\n  // Only build these once, since we might be checking them many times\n  try {\n    var sPoly = turfPolygon([subject]);\n    var cPoly = turfPolygon([clipper]);\n  } catch (err) {\n    console.log(\"Clipping error: bad polygons!\")\n    console.log(subject)\n    console.log(\"-------------------\")\n    console.log(clipper)\n  }\n\n  // These can be manipulated to change the output operation:\n  //\n  //  Operation        | s_forward   | c_forward\n  // -----------------------------------------------\n  //  Union            | false       | false\n  //  Intersect        | true        | true\n  //  Subtract (A - B) | false       | true\n  //  Subtract (B - A) | true        | false\n  //\n  s_forward = !!s_forward;\n  c_forward = !!c_forward;\n\n  if (!s_forward && !c_forward) {\n    mode = 'union';\n  } else if (s_forward && c_forward) {\n    mode = 'intersect';\n  } else if (!s_forward && c_forward) {\n    mode = 'subtractB'; // A - B\n  } else if (s_forward && !c_forward) {\n    mode = 'subtractA'; // B - A\n  }\n\n  // Greiner-Hormann clipping uses 3 phases:\n  //  1. Find intersection vertices, build data structure\n  //  2. Mark vertices as entry/exit points\n  //  3. Build Polygons\n  //\n  //  We additionally add in some special case handling\n  //  at the end, because GH won't handle cases where\n  //  one of the polygons fully encloses the other, or\n  //  the two polygons are totally disjoint\n  var sPoints = Ring.fromArray(subject);\n  var cPoints = Ring.fromArray(clipper);\n\n  /**\n   * PHASE ONE: Identify Intersections\n   */\n  var vertices = buildIntersectionLists(sPoints, cPoints, sPoly, cPoly);\n  markDegensAsIntersect(sPoints);\n\n\n  /**\n   * OPTIMIZATION: check for known cases where we can bail out early\n   */\n  var maybeResult;\n  if (maybeResult = checkQuitCases(sPoints, cPoints, subject, clipper, mode)) {\n    return maybeResult;\n  }\n\n  /**\n   * PHASE TWO: Identify Entry/Exit\n   */\n  setEntryExit(sPoints);\n  // logPoints(sPoints, cPoints);\n\n  /**\n   * PHASE THREE: Build clipped polys\n   */\n  return buildPolygons(sPoints, s_forward, c_forward);\n}\n\n/**\n * Handles some cases here we can bail out without fully computing the intersection.\n *\n * @return {[type]} [description]\n */\nfunction checkQuitCases(sPoints, cPoints, subject, clipper, mode) {\n  var totalS = sPoints.count();\n  var totalC = cPoints.count();\n\n  // No intersections exist\n  if (sPoints.count('intersect', true) === 0) {\n    switch (mode) {\n      case \"union\":\n        // Return both shapes as a multipolygon\n        return [[subject], [clipper]];\n        break;\n      case \"intersect\":\n        // There's no intersection, return nothing.\n        return [];\n        break;\n      case \"subtractB\":\n        // If B is inside of A, it's a hole.\n        if (cPoints.first.type == \"in\") {\n          return [[subject, clipper]];\n        }\n        // Otherwise it's disjoint, so we ignore it.\n        return [[subject]]\n        break;\n      case \"subtractA\":\n        // If A is inside of B, it's a hole.\n        if (sPoints.first.type == \"in\") {\n          return [[clipper, subject]];\n        }\n        // Otherwise it's disjoint, so we ignore it.\n        return [[clipper]];\n        break;\n    }\n  }\n\n  // All points are degenerate. The shapes are spatially equal.\n  if (totalS == sPoints.count('degenerate', true)) {\n    switch (mode) {\n      case \"subtractA\":\n      case \"subtractB\":\n        return [];\n        break;\n      default:\n        return [[subject]];\n    }\n  }\n}\n\n\n/**\n * Builds the list of Polygon(s) representing the desired overlap of\n * the subject/clipper.\n *\n * @param  {[type]} sPoints [description]\n * @return {[type]}         [description]\n */\nfunction buildPolygons(sPoints, s_forward, c_forward) {\n  var curr = sPoints.first;\n  var polylist = [];\n  var onclip = false;\n  var endir = 'next';\n  var exdir = 'prev';\n\n  while (curr = sPoints.firstIntersect()) {\n    var poly = [[curr.x, curr.y]];\n\n    do {\n      if (onclip) {\n        endir = c_forward ? 'next' : 'prev';\n        exdir = c_forward ? 'prev' : 'next';\n      } else {\n        endir = s_forward ? 'next' : 'prev';\n        exdir = s_forward ? 'prev' : 'next';\n      }\n\n      curr.checked = true;\n      if (curr.neighbor) {\n        curr.neighbor.checked = true;\n      }\n\n      if (curr.entry) {\n        do {\n            curr = curr[endir];\n            poly.push([curr.x, curr.y]);\n        } while (!curr.intersect);\n      } else {\n        do {\n          curr = curr[exdir];\n          poly.push([curr.x, curr.y]);\n        } while (!curr.intersect);\n      }\n\n      // Jump to the other list\n      curr = curr.neighbor;\n      onclip = !onclip;\n\n    } while (!curr.checked);\n    //poly.push(poly[0])\n    polylist.push([poly])\n  }\n  return polylist;\n}\n\n/**\n * Builds vertex lists for the subject and clipper. Essentially\n * the way this will work is that it will detect intersections by\n * comparing each pair of lines between the subject / clipper, then\n * injecting intersection vertices (marked by the \"intersects\" property)\n * in the appropriate spots in each coordinate list.\n *\n * Once this is complete, our subject and clipper coordinate lists will\n * each contain, in traversable order, every vertex, including ones for\n * each point where the other polygon intersected.\n *\n * @param  {[type]} sPoints [description]\n * @param  {[type]} cPoints [description]\n * @return {[type]}         [description]\n */\nfunction buildIntersectionLists(sPoints, cPoints, sPoly, cPoly) {\n  var sCurr = sPoints.first;\n\n  do {\n    setPointRelativeLocation(sCurr, cPoly)\n    var cCurr = cPoints.first;\n    if (!sCurr.intersect) {\n      do {\n        setPointRelativeLocation(cCurr, sPoly)\n        if (!cCurr.intersect) {\n          var sEnd = sPoints.nextNonIntersect(sCurr.next);\n          var cEnd = cPoints.nextNonIntersect(cCurr.next);\n          var intersect = lineIntersects(sCurr, sEnd, cCurr, cEnd);\n\n          if (intersect) {\n            cCurr = handleIntersection(sPoints, cPoints, sCurr, sEnd, cCurr, cEnd, intersect);\n          }\n        }\n\n        cCurr = cCurr.next;\n      } while (cCurr !== cPoints.first);\n    }\n\n    sCurr = sCurr.next;\n  } while (sCurr !== sPoints.first);\n}\n\n/**\n * Loop back through, ensuring that all degenerate vertices\n * are marked as intersections.\n *\n * @param  {Ring} points [description]\n * @return {[type]}        [description]\n */\nfunction markDegensAsIntersect(points) {\n  var curr = points.first;\n\n  do {\n    if (curr.degenerate) {\n      curr.intersect = true;\n      curr.neighbor.intersect = true;\n    }\n    curr = curr.next\n  } while (curr != points.first)\n}\n\n/**\n * Handle inserting / replacing points appropriately for\n * a found intersection\n *\n * @param  {Ring}   sPoints   Subject Ring\n * @param  {Ring}   cPoints   Clip Ring\n * @param  {Vertex} sCurr     Start of the Subject line\n * @param  {Vertex} sEnd      End of the Subject line\n * @param  {Vertex} cCurr     Start of the Clip line\n * @param  {Vertex} cEnd      End of the Clip line\n * @param  {Object} intersect Object representing an intersection\n * @return {[type]}           [description]\n */\nfunction handleIntersection(sPoints, cPoints, sCurr, sEnd, cCurr, cEnd, intersect) {\n  var sPt, cPt;\n  var s_between = 0 < intersect.alphaA && intersect.alphaA < 1;\n  var c_between = 0 < intersect.alphaB && intersect.alphaB < 1;\n\n  if (s_between && c_between) {\n    sPt = new Vertex(intersect.x, intersect.y, intersect.alphaA, true);\n    cPt = new Vertex(intersect.x, intersect.y, intersect.alphaB, true);\n    sPoints.insert(sPt, sCurr, sEnd);\n    cPoints.insert(cPt, cCurr, cEnd);\n  } else {\n    // Handle various degeneracy cases for the subject point\n    if (s_between) {\n      sPt = new Vertex(intersect.x, intersect.y, intersect.alphaA, true, true);\n      sPoints.insert(sPt, sCurr, sPoints.nextNonIntersect(sCurr.next));\n    } else if (intersect.alphaA == 0) {\n      sCurr.intersect = true;\n      sCurr.degenerate = true;\n      sCurr.alpha = intersect.alphaA;\n      sPt = sCurr;\n    } else if (intersect.alphaA == 1) {\n      // End points get marked as degenerate but don't get marked as intersects.\n      // This allows us to catch them later, and still use them for generating\n      // lines to test against the other polygon\n      sEnd.intersect = false;\n      sEnd.degenerate = true;\n      sEnd.alpha = intersect.alphaA;\n      sPt = sEnd;\n    }\n\n    // Handle various degeneracy cases for the clip point\n    if (c_between) {\n      cPt = new Vertex(intersect.x, intersect.y, intersect.alphaB, true, true);\n      cPoints.insert(cPt, cCurr, cPoints.nextNonIntersect(cCurr.next));\n    } else if (intersect.alphaB == 0) {\n      cCurr.intersect = true;\n      cCurr.degenerate = true;\n      cCurr.alpha = intersect.alphaB;\n      cPt = cCurr;\n    } else if (intersect.alphaB == 1) {\n      // End points get marked as degenerate but don't get marked as intersects.\n      // This allows us to catch them later, and still use them for generating\n      // lines to test against the other polygon\n      cEnd.intersect = false;\n      cEnd.degenerate = true;\n      cEnd.alpha = intersect.alphaB;\n      cPt = cEnd;\n      if (cCurr.next != cPoints.first) {\n        cCurr = cCurr.next;\n      }\n    }\n  }\n\n  // Neighbors are used to jump back and forth between the lists\n  if (sPt && cPt) {\n    sPt.neighbor = cPt;\n    cPt.neighbor = sPt;\n    // Intersections are always \"on\" a line\n    sPt.type = \"on\";\n    cPt.type = \"on\";\n  }\n  return cCurr;\n}\n\n/**\n * Set a point in or out compared to the other polygon:\n * - if it's a subject point, compare to the clip polygon,\n * - if it's a clip point, compare to the subject polygon\n *\n * @param {Vertex}  pt   Point to check against the poly\n * @param {Polygon} poly Check if pt is within this poly\n */\nfunction setPointRelativeLocation(pt, poly) {\n  if (!pt.type) {\n    if (turfInside(turfPoint([pt.x, pt.y]), poly)) {\n      pt.type = \"in\";\n    } else {\n      pt.type = \"out\";\n    }\n  }\n}\n\n/**\n * Handle setting entry/exit flags for each intersection. This is\n * where a large part of degeneracy handling happens - the original\n * GH algorithm uses very simple entry/exit handling, which won't work\n * for our degenerate cases.\n *\n * http://arxiv-web3.library.cornell.edu/pdf/1211.3376v1.pdf\n *\n * @param {Ring}    sPoints The subject polygon's vertices\n */\nfunction setEntryExit(sPoints) {\n  var first = sPoints.first;\n  var curr = first;\n\n  do {\n    if (curr.intersect && curr.neighbor) {\n      handleEnEx(curr);\n      handleEnEx(curr.neighbor);\n\n      // If this and the neighbor share the same entry / exit flag values\n      // we need to throw them out and relabel\n      switch (curr.entryPair()) {\n        case \"en/en\":\n          curr.remove = true;\n          curr.type = \"in\";\n          curr.intersect = false;\n          curr.neighbor.intersect = false;\n          break;\n        case \"ex/ex\":\n          curr.remove = true;\n          curr.type = \"out\";\n          curr.intersect = false;\n          curr.neighbor.intersect = false;\n          break;\n      }\n    }\n\n    curr = curr.next;\n  } while (curr != first)\n}\n\n/**\n * Handles deciding the entry / exit flag setting for a given point.\n * This is probably where most of the things could be wrong\n *\n * @param  {Vertex} curr The vertex to flag\n */\nfunction handleEnEx(curr) {\n  var cp = curr.pairing();\n  switch (cp) {\n      case \"in/out\":\n      case \"on/out\":\n      case \"in/on\":\n        curr.entry = false;\n        break;\n      case \"out/in\":\n      case \"on/in\":\n      case \"out/on\":\n        curr.entry = true;\n        break;\n      case \"out/out\":\n      case \"in/in\":\n      case \"on/on\":\n        var np = curr.neighbor.pairing();\n        if (np == \"out/out\" || np == \"in/in\" || np == \"on/on\" || (cp == \"on/on\" && np == \"on/out\")) {\n          curr.remove = true;\n          curr.neighbor.remove = true;\n          curr.neighbor.intersect = false;\n          curr.intersect = false;\n        } else {\n          handleEnEx(curr.neighbor);\n          curr.entry = !curr.neighbor.entry;\n        }\n        break;\n      default:\n        // This shouldn't ever happen - It's here to confirm nothing stupid is happening.\n        console.error(\"UNKNOWN TYPE\", curr.pairing())\n    }\n}\n\n\n/**\n * Take two lines (each represented by the respective\n * start and end), and tells you where they intersect,\n * as well as the intersection alphas\n *\n * @param  {Vertex} start1 [description]\n * @param  {Vertex} end1   [description]\n * @param  {Vertex} start2 [description]\n * @param  {Vertex} end2   [description]\n * @return {[type]}        [description]\n */\nfunction lineIntersects(start1, end1, start2, end2) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, numerator1, numerator2, result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false,\n    alphaA: null,\n    alphaB: null,\n  };\n  denominator = ((end2.y - start2.y) * (end1.x - start1.x)) - ((end2.x - start2.x) * (end1.y - start1.y));\n  if (denominator == 0) {\n    if (start1.equals(start2)) {\n      result.x = start1.x\n      result.y = start1.y\n      result.alphaA = 0;\n      result.alphaB = 0;\n      return result;\n    }\n    return false;\n  }\n\n  a = start1.y - start2.y;\n  b = start1.x - start2.x;\n  numerator1 = ((end2.x - start2.x) * a) - ((end2.y - start2.y) * b);\n  numerator2 = ((end1.x - start1.x) * a) - ((end1.y - start1.y) * b);\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  // if we cast these lines infinitely in both directions, they intersect here:\n  result.x = start1.x + (a * (end1.x - start1.x));\n  result.y = start1.y + (a * (end1.y - start1.y));\n  result.alphaA = a;\n  result.alphaB = b;\n\n  // TODO: any better way to handle this?\n  if (result.alphaA > 0.99999999999999) {\n    result.alphaA = 1;\n  }\n  if (result.alphaB > 0.99999999999999) {\n    result.alphaB = 1;\n  }\n  if (result.alphaA < 0.00000000000001) {\n    result.alphaA = 0;\n  }\n  if (result.alphaB < 0.00000000000001) {\n    result.alphaB = 0;\n  }\n\n  // if line1 is a segment and line2 is infinite, they intersect if:\n  if (0 <= a && a <= 1) {\n    result.onLine1 = true;\n  }\n  // if line2 is a segment and line1 is infinite, they intersect if:\n  if (0 <= b && b <= 1) {\n    result.onLine2 = true;\n  }\n  // if line1 and line2 are segments, they intersect if both of the above are true\n  if(result.onLine1 && result.onLine2){\n    return result;\n  }\n  else {\n    return false;\n  }\n}\n\n\n/**\n * Utility method for logging points\n *\n * @param  {[type]} sPoints [description]\n * @param  {[type]} cPoints [description]\n * @return {[type]}         [description]\n */\nfunction logPoints(sPoints, cPoints) {\n  console.log(\"POINTS\")\n  console.log(\"-----------------\")\n  var curr = sPoints.first\n  do {\n    curr.log();\n    curr = curr.next\n  } while (curr != sPoints.first)\n  console.log(\"-----------------\")\n  if (!cPoints) return;\n  var curr = cPoints.first\n  do {\n    curr.log();\n    curr = curr.next\n  } while (curr != cPoints.first)\n}\n\n/**\n * Utility method for logging intersecions and degenerate points\n *\n * @param  {[type]} sPoints [description]\n * @return {[type]}         [description]\n */\nfunction logIntersections(sPoints) {\n  console.log(\"-------------------\")\n  console.log(\"INTERSECTION LIST: \")\n  console.log(\"-------------------\")\n  var curr = sPoints.first\n  do {\n    if (curr.intersect || curr.degenerate) {\n      curr.log()\n    }\n    curr = curr.next\n  } while (curr != sPoints.first)\n  console.log(\"\")\n}\n\n\n",
    "var ghClipping = require('./greiner-hormann');\nvar turfInside = require('turf-inside');\nvar turfPoint = require('turf-point');\nvar turfPolygon = require('turf-polygon');\nvar union = require('./union');\nvar utils = require('./util');\nvar subtract = require('./subtract');\n\nmodule.exports = function(subject, clipper) {\n  var subject = utils.clone(subject);\n  var clipper = utils.clone(clipper);\n  var hulls = utils.outerHulls(subject).concat(utils.outerHulls(clipper));\n  var holes = utils.holes(subject).concat(utils.holes(clipper));\n  var result = [];\n\n  for (var i = 0; i < hulls.length; i++) {\n    for (var j = i+1; j < hulls.length; j++) {\n      var test = ghClipping(hulls[i], hulls[j], true, true);\n      if (Array.isArray(test)) {\n        result = result.concat(test);\n      }\n    }\n  }\n\n  // Union all the holes then subtract them rom the result\n  if (holes.length > 0) {\n    var holeUnion = union(holes);\n\n    return subtract(result, utils.outerHulls(holeUnion));\n  }\n\n  return result;\n}\n",
    "Vertex = require('./vertex');\n\n/**\n * Ring is a circular doubly-linked list; Every node\n * has a next and a prev, even if it's the only node in the list.\n *\n * This supports some search methods that need to wrap back to the start of the list.\n */\nfunction Ring () {\n    this.first = null;\n}\n\nRing.prototype.count = function(countkey, countval) {\n    var curr = this.first;\n    var count = 0;\n    while (true) {\n        if (countkey) {\n            if (curr[countkey] === countval) {\n                count++;\n            }\n        } else {\n            count++;\n        }\n        curr = curr.next;\n\n        if (curr == this.first) {\n            break;\n        }\n    }\n    return count;\n}\n\n\n/**\n * Takes an array of coordinates and constructs a Ring\n *\n * @param  {array} coordinates   the array of coordinates to convert to a Ring\n * @return {Ring}\n */\nRing.fromArray = function(coordinates) {\n    var ring = new Ring()\n\n    for (var i = 0; i < (coordinates.length - 1); i++) {\n        var elem = coordinates[i];\n        ring.push(new Vertex(elem[0], elem[1]));\n    }\n\n    return ring;\n}\n\n/**\n * Push a vertex into the ring's list. This\n * just updates pointers to put the point at\n * the end of the list\n *\n * @param  {Vertex} vertex the vertex to push\n */\nRing.prototype.push = function(vertex) {\n    if (!this.first) {\n        this.first = vertex;\n        this.first.prev = vertex;\n        this.first.next = vertex;\n    } else {\n        next = this.first;\n        prev = next.prev;\n        next.prev = vertex;\n        vertex.next = next;\n        vertex.prev = prev;\n        prev.next = vertex;\n    }\n}\n\n/**\n * Insert a vertex between specific vertices\n *\n * If there are intersection points, inbetween\n * start and end, the new vertex is inserted\n * based on it's alpha value\n *\n * @param  {Vertex} vertex the vertex to insert\n * @param  {Vertex} start  the \"leftmost\" vertex this point could be inserted next to\n * @param  {Vertex} end    the \"rightmost\" vertex this could could be inserted next to\n */\nRing.prototype.insert = function(vertex, start, end) {\n    var curr = start.next;\n\n    while (curr != end && curr.alpha < vertex.alpha) {\n        curr = curr.next;\n    }\n\n    // Insert just before the \"curr\" value\n    vertex.next = curr;\n    prev = curr.prev;\n    vertex.prev = prev;\n    prev.next = vertex;\n    curr.prev = vertex;\n}\n\n/**\n * Start at the start vertex, and get the next\n * point that isn't an intersection\n *\n * @param  {Vertex} start the vertex to start searching at\n * @return {Vertex} the next non-intersect\n */\nRing.prototype.nextNonIntersect = function (start) {\n    var curr = start;\n    while (curr.intersect && curr != this.first) {\n        curr = curr.next\n    }\n    return curr;\n}\n\n/**\n * Returns the first unchecked intersection in the list\n *\n * @return {Vertex|bool}\n */\nRing.prototype.firstIntersect = function () {\n    var curr =  this.first;\n\n    while (true) {\n        if (curr.intersect && !curr.checked) {\n            return curr;\n        }\n\n        curr = curr.next;\n\n        if (curr == this.first) {\n            break;\n        }\n    }\n    return false;\n}\n\n/**\n * Converts the Ring into an array\n *\n * @return {array} array representation of the ring\n */\nRing.prototype.toArray = function () {\n    var curr = this.first;\n    var points = [];\n\n    do {\n        points.push([curr.x, curr.y]);\n        curr = curr.next;\n    } while (curr != this.first);\n\n    return points;\n}\n\nmodule.exports = Ring;\n",
    "var util = require('./util');\nvar ghClipping = require('./greiner-hormann');\n\nmodule.exports = function(subject, clip) {\n  subject = util.clone(subject);\n  clip = util.clone(clip);\n  // TODO:\n  // Subtract each outer hull of the clip from the subject\n  // If there are any holes in the subject, subtract those as well\n  // If there are any holes in the clip, which overlap the original\n  // subject, these should be unioned in. This means we'll have to\n  // check polygon within-ness for each clip hole\n\n  // Next we'll subtract each hole from each intersection polygon.\n  for (var i = 0; i < clip.length; i++) {\n    var ilen = subject.length;\n    for (var j = 0; j < subject.length; j++) {\n      var test = ghClipping(subject[j][0], clip[i], false, true);\n      // Copy the primary hull of the intersect record that\n      // we just clipped against the hull\n      subject[j][0] = test[0][0];\n\n      // Copy in each hole (if there were any) for the primary hull\n      for (var k = 1; k < test[0].length; k++) {\n        subject[j].push(test[0][k]);\n      }\n\n      // If there are any additional polygons in the result,\n      // they were newly created by intersecting this hole.\n      // Push the new polygon (hull and any holes) straight\n      // into the intersect list\n      for (var k = 1; k < test.length; k++) {\n        subject.push(test[k]);\n      }\n    }\n\n    // If the length has changed, this hole created\n    // new intersection polygons, which means it's not a hole\n    // anymore (it crossed the polys, now it's boundary is\n    // part of the new intersection hulls). Therefore, we\n    // remove this hole from the list so it won't be returned.\n    if (ilen != subject.length) {\n      clip.splice(i, 1)\n      i--;\n    }\n  }\n\n  return subject;\n}\n",
    "var ghClipping = require('./greiner-hormann');\nvar utils = require('./util');\nvar subtract = require('./subtract');\n\n/**\n * Iteratively join all rings in the passed set.\n *\n * @param  {array} rings An array of polygon rings\n * @return {[type]}       [description]\n */\nfunction unionRings(rings)\n{\n  for (var i = 0; i < rings.length; i++) {\n    for (var j = i+1; j < rings.length; j++) {\n      if (i == j) {\n        continue;\n      }\n      var test = utils.outerHulls(ghClipping(rings[i], rings[j], false, false));\n\n      // If the length is 1, we joined the two areas, so replace\n      // rings[i] with the new shape, and remove rings[j]\n      // Then reset the j iterator so we can make sure that none of\n      // the previous rings will now overlap the new rings[i]\n      if (test.length == 1) {\n        rings[i] = test[0];\n        rings.splice(j, 1);\n        j = i;\n      }\n    }\n  }\n  return rings;\n}\n\n// TODO: make this support polys + holes. Right now\n// it takes an array of rings, not array of polys.\n//\n// TODO: think about the function signature here? Should it be\n// traditional \"union A + B\", or is passing a set of things to union more useful\n//\n// TODO: think about using the approach here: http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html\n// to make things faster for complex / very degenerate sets\nmodule.exports = function(coords, coords2) {\n  if (typeof coords2 != 'undefined' && coords2 != null) {\n    // TODO: make this more robust. This will fail in some cases\n    if (!utils.isMultiPolygon(coords)) {\n      coords = [coords];\n    }\n    if (!utils.isMultiPolygon(coords2)) {\n      coords2 = [coords2];\n    }\n    coords = coords.concat(coords2)\n  }\n\n\n  coords = utils.clone(coords);\n  var hulls = utils.outerHulls(coords);\n  var holes = utils.holes(coords);\n\n  // Union all hulls\n  hulls = utils.wrapToPolygons(unionRings(hulls));\n\n  // Union all holes - If holes overlap, they should be joined\n  if (holes.length > 0) {\n    holes = unionRings(holes);\n\n    // Subtract all rings from the unioned set\n    return subtract(hulls, holes);\n  }\n\n  return hulls;\n}\n",
    "if (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n\n// deep clone an array of coordinates / polygons\nexports.clone = function(array) {\n  var new_arr = [];\n  for (var i = 0; i < array.length; i++) {\n    if (Array.isArray(array[i])){\n      new_arr.push(exports.clone(array[i]).slice());\n    } else {\n      new_arr.push(array[i]);\n    }\n  }\n  return new_arr;\n}\n\n// Wrap an array of geometries to an array of polygons\nexports.wrapToPolygons = function(array) {\n  var wrapped = [];\n  for(var i = 0; i < array.length; i++) {\n    if (exports.isRing(array[i])) {\n      wrapped.push([array[i]]);\n    } else if (exports.isMultiPolygon(array[i])) {\n      wrapped.concat(array[i]);\n    } else if (exports.isPolygon(array[i])) {\n      wrapped.push(array[i]);\n    }\n  }\n  return wrapped;\n}\n\n// Unwrap polygons to an array of rings\nexports.unwrap = function(array) {\n  var unwrapped = [];\n  for (var i = 0; i < array.length; i++) {\n    for (var j = 0; j < array[i].length; j++) {\n      unwrapped.push(array[i][j]);\n    }\n  }\n}\n\n\n/**\n * Count array depth (used to check for geom type)\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.depth = function(collection) {\n  function depth(collection, num) {\n    if (Array.isArray(collection)) {\n      return depth(collection[0], num+1);\n    }\n    return num;\n  }\n\n  return depth(collection, 0);\n}\n\n\nexports.isMultiPolygon = function(poly) {\n  if (exports.depth(poly) == 4) {\n    return true;\n  }\n  return false;\n}\n\n\nexports.isPolygon = function(poly) {\n  if (exports.depth(poly) == 3) {\n    return true;\n  }\n  return false;\n}\n\nexports.isRing = function(poly) {\n  if(exports.depth(poly) == 2) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Takes a list of polygons / multipolygons and returns only the outer hulls\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.outerHulls = function(collection) {\n  var hulls = [];\n\n  if (exports.isPolygon(collection)) {\n    return [collection[0]];\n  }\n\n  for (var i = 0; i < collection.length; i++) {\n    if (exports.isMultiPolygon(collection[i])) {\n      // Each polygon\n      for (var j = 0; j < collection[i].length; j++) {\n        hulls.push(collection[i][j][0]);\n      }\n    } else if (exports.isPolygon(collection[i])) {\n      hulls.push(collection[i][0]);\n    } else if (exports.isRing(collection[i])) {\n      hulls.push(collection[i]);\n    }\n  }\n\n  return hulls;\n}\n\n/**\n * Takes a list of multipolygons / polygons and returns only the holes\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.holes = function(collection) {\n  var holes = [];\n\n  if (exports.isPolygon(collection)) {\n    return collection.slice(1)\n  }\n\n  for (var i = 0; i < collection.length; i++) {\n    if (exports.isMultiPolygon(collection[i])) {\n      // Each polygon\n      for (var j = 0; j < collection[i].length; j++) {\n        for (var k = 1; k < collection[i][j].length; k++) {\n          holes.push(collection[i][j][k]);\n        }\n      }\n    } else if (exports.isPolygon(collection[i])) {\n      for (var j = 1; j < collection[i].length; j++) {\n        holes.push(collection[i][j]);\n      }\n    }\n  }\n\n  return holes;\n}\n",
    "function Vertex (x, y, alpha, intersect, degenerate) {\n    this.x = x;\n    this.y = y;\n    this.alpha = alpha || 0.0;\n    this.intersect = intersect || false;\n    this.entry = true; // Set to true by default, for degeneracy handling\n    this.checked = false;\n    this.degenerate = degenerate || false;\n    this.neighbor = null;\n    this.next = null;\n    this.prev = null;\n    this.type = null; // can be \"in\", \"out\", \"on\"\n    this.remove = false;\n}\n\n/**\n * Returns a string representing the types of the previous and next vertices.\n * For example, if the prev vertex had type \"in\" and the next had type \"out\",\n * the pairing would be \"in/out\". This matches the way pairs are referenced in\n * the Greiner-Hormann Degeneracy paper.\n *\n * @return {String} the pairing description\n */\nVertex.prototype.pairing = function () {\n    return this.prev.type + \"/\" + this.next.type;\n}\n\n/**\n * Returns a string representing the entry / exit flag of this vertex and it's neighbor\n * For example, if the current vertex was flagged entry = true and it's neighbor was flagged\n * entry = false, the entryPair would be \"en/ex\" (short for \"entry/exit\"). This matches the\n * way flags are referenced in the Greiner-Hormann Degeneracy paper.\n *\n * @return {String} the entry/exit pair string\n */\nVertex.prototype.entryPair = function() {\n    var entry = this.entry ? \"en\" : \"ex\";\n    var nEntry = this.neighbor.entry ? \"en\" : \"ex\";\n\n    return entry+\"/\"+nEntry;\n}\n\n/**\n * Determine if this vertex is equal to another\n *\n * @param  {Vertex} other the vertex to compare with\n * @return {bool}   whether or not the vertices are equal\n */\nVertex.prototype.equals = function(other) {\n    if (this.x == other.x && this.y == other.y) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Utility method to log the vertex, only for debugging\n */\nVertex.prototype.log = function() {\n  console.log(\n      \"INTERSECT: \"+ (this.intersect ? \"Yes\" : \"No \")\n      +\" ENTRY: \"+(this.entry ? \"Yes\": \"No \")\n      +\" DEGEN: \"+(this.degenerate ? \"Yes\": \"No \")\n      +\" TYPE: \"+String(this.prev.type+\" \").slice(0, 3)\n          +\" / \"+String(this.type+\" \").slice(0, 3)\n          +\" / \"+String(this.next.type+\" \").slice(0, 3)\n      +\" ALPHA: \"+ this.alpha.toPrecision(3)\n      +\" REMOVE: \"+ (this.remove ? \"Yes\": \"No\") + \" \"\n      +this.x + \", \"+this.y\n    );\n};\n\n\nmodule.exports = Vertex;\n",
    "// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} feature and a {@link Polygon} feature and determines if the Point resides inside the Polygon. The Polygon can\n * be convex or concave. The function accepts any valid Polygon or {@link MultiPolygon}\n * and accounts for holes.\n *\n * @module turf/inside\n * @category joins\n * @param {Point} point a Point feature\n * @param {Polygon} polygon a Polygon feature\n * @return {Boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt1 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#f00\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-111.467285, 40.75766]\n *   }\n * };\n * var pt2 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#0f0\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-111.873779, 40.647303]\n *   }\n * };\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [-112.074279, 40.52215],\n *       [-112.074279, 40.853293],\n *       [-111.610107, 40.853293],\n *       [-111.610107, 40.52215],\n *       [-112.074279, 40.52215]\n *     ]]\n *   }\n * };\n *\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [pt1, pt2, poly]\n * };\n *\n * //=features\n *\n * var isInside1 = turf.inside(pt1, poly);\n * //=isInside1\n *\n * var isInside2 = turf.inside(pt2, poly);\n * //=isInside2\n */\nmodule.exports = function(point, polygon) {\n  var polys = polygon.geometry.coordinates;\n  var pt = [point.geometry.coordinates[0], point.geometry.coordinates[1]];\n  // normalize to multipolygon\n  if(polygon.geometry.type === 'Polygon') polys = [polys];\n\n  var insidePoly = false;\n  var i = 0;\n  while (i < polys.length && !insidePoly) {\n    // check if it is in the outer ring first\n    if(inRing(pt, polys[i][0])) {\n      var inHole = false;\n      var k = 1;\n      // check for the point in any of the holes\n      while(k < polys[i].length && !inHole) {\n        if(inRing(pt, polys[i][k])) {\n          inHole = true;\n        }\n        k++;\n      }\n      if(!inHole) insidePoly = true;\n    }\n    i++;\n  }\n  return insidePoly;\n}\n\n// pt is [x,y] and ring is [[x,y], [x,y],..]\nfunction inRing (pt, ring) {\n  var isInside = false;\n  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n    var xi = ring[i][0], yi = ring[i][1];\n    var xj = ring[j][0], yj = ring[j][1];\n    \n    var intersect = ((yi > pt[1]) != (yj > pt[1]))\n        && (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n    if (intersect) isInside = !isInside;\n  }\n  return isInside;\n}\n\n",
    "module.exports = function(ring){\n  var sum = 0;\n  var i = 1;\n  var len = ring.length;\n  var prev,cur;\n  while(i<len){\n    prev = cur||ring[0];\n    cur = ring[i];\n    sum += ((cur[0]-prev[0])*(cur[1]+prev[1]));\n    i++;\n  }\n  return sum > 0;\n}",
    "/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @module turf/point\n * @category helper\n * @param {number} longitude position west to east in decimal degrees\n * @param {number} latitude position south to north in decimal degrees\n * @param {Object} properties an Object that is used as the {@link Feature}'s\n * properties\n * @return {Point} a Point feature\n * @example\n * var pt1 = turf.point([-75.343, 39.984]);\n *\n * //=pt1\n */\nvar isArray = Array.isArray || function(arg) {\n  return Object.prototype.toString.call(arg) === '[object Array]';\n};\nmodule.exports = function(coordinates, properties) {\n  if (!isArray(coordinates)) throw new Error('Coordinates must be an array');\n  if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"Point\",\n      coordinates: coordinates\n    },\n    properties: properties || {}\n  };\n};\n",
    "/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a GeoJSON {@link Polygon} feature.\n *\n * @module turf/polygon\n * @category helper\n * @param {Array<Array<Number>>} rings an array of LinearRings\n * @param {Object} properties an optional properties object\n * @return {Polygon} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the\n * beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *  [-2.275543, 53.464547],\n *  [-2.275543, 53.489271],\n *  [-2.215118, 53.489271],\n *  [-2.215118, 53.464547],\n *  [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nmodule.exports = function(coordinates, properties){\n\n  if (coordinates === null) throw new Error('No coordinates passed');\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var ring = coordinates[i];\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring.length < 4) {\n        throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n      }\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error('First and last Position are not equivalent.');\n      }\n    }\n  }\n\n  var polygon = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n      \"type\": \"Polygon\",\n      \"coordinates\": coordinates\n    },\n    \"properties\": properties\n  };\n\n  if (!polygon.properties) {\n    polygon.properties = {};\n  }\n\n  return polygon;\n};\n"
  ]
}