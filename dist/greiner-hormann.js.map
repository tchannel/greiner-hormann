{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "index.js",
    "lib/greiner-hormann.js",
    "lib/intersect.js",
    "lib/ring.js",
    "lib/subtract.js",
    "lib/union.js",
    "lib/util.js",
    "lib/vertex.js",
    "node_modules/point-in-polygon/index.js",
    "node_modules/turf-is-clockwise/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "module.exports = {\n  union: require('./lib/union'),\n  intersect: require('./lib/intersect'),\n  subtract: require('./lib/subtract'),\n\n  // include utils to make things easier\n  utils: require('./lib/util')\n};\n",
    "var Ring = require('./ring');\nvar Vertex = require('./vertex');\nvar pip = require('point-in-polygon');\nvar util = require('./util');\n\n/**\n * Greiner-Hormann clipping uses 3 phases:\n *\n * 1. Find intersection vertices, build data structure\n * 2. Mark vertices as entry/exit points\n * 3. Build Polygons\n *\n * We additionally add in some special case handling\n * after intersection detection, because GH won't handle\n * cases where one of the polygons fully encloses the other,\n * or the two polygons are totally disjoint\n */\nmodule.exports = function(subject, clipper, s_forward, c_forward) {\n  s_forward = !!s_forward;\n  c_forward = !!c_forward;\n\n  var mode = detectMode(s_forward, c_forward);\n  var sPoints = Ring.fromArray(subject);\n  var cPoints = Ring.fromArray(clipper);\n\n\n  /**\n   * PHASE ONE: Identify Intersections\n   */\n  var vertices = buildIntersectionLists(sPoints, cPoints, subject, clipper);\n  markDegensAsIntersect(sPoints);\n\n  /**\n   * OPTIMIZATION / EDGE CASES: check for known cases where we can bail out early\n   */\n  var maybeResult;\n  if (maybeResult = checkQuitCases(sPoints, cPoints, subject, clipper, mode)) {\n    return maybeResult;\n  }\n\n  /**\n   * PHASE TWO: Identify Entry/Exit (Includes Degeneracy labelling logic)\n   */\n  setEntryExit(sPoints);\n\n  /**\n   * PHASE THREE: Build clipped polys\n   */\n  res = buildPolygons(sPoints, s_forward, c_forward);\n\n  if(!res || res.length == 0) {\n    logPoints(sPoints, cPoints);\n  }\nreturn res;\n}\n\n/**\n * s_forward and c_forward can be manipulated to change the operation\n * applied to the subject / clipper. This method provides a string\n * representation of the mode for easy reference.\n *\n *  Operation        | s_forward   | c_forward\n * -----------------------------------------------\n *  Union            | false       | false\n *  Intersect        | true        | true\n *  Subtract (A - B) | false       | true\n *  Subtract (B - A) | true        | false\n *\n * @param  {bool} s_forward whether to traverse the subject polygon in forward order\n * @param  {bool} c_forward whether to traverse the clip polygon in forward order\n * @return {string}           the string description of the selected clip mode\n */\nfunction detectMode(s_forward, c_forward) {\n  if (!s_forward && !c_forward) {\n    mode = 'union';\n  } else if (s_forward && c_forward) {\n    mode = 'intersect';\n  } else if (!s_forward && c_forward) {\n    mode = 'subtractB'; // A - B\n  } else if (s_forward && !c_forward) {\n    mode = 'subtractA'; // B - A\n  }\n  return mode;\n}\n\n/**\n * Handles some cases here we can bail out without fully computing the intersection.\n *\n * @return {array|null} the result polygons, if an edge case was handled\n */\nfunction checkQuitCases(sPoints, cPoints, subject, clipper, mode) {\n  var totalS = sPoints.count();\n  var totalC = cPoints.count();\n\n  // No intersections exist\n  if (sPoints.count('intersect', true) === 0) {\n    switch (mode) {\n      case \"union\":\n        // Return both shapes as a multipolygon\n        return [[subject], [clipper]];\n        break;\n      case \"intersect\":\n        // There's no intersection, return nothing.\n        return [];\n        break;\n      case \"subtractB\":\n        // If B is inside of A, it's a hole.\n        if (cPoints.first.type == \"in\") {\n          return [[subject, clipper]];\n        }\n        if (sPoints.count('type', 'in') == totalS) {\n          return [];\n        }\n\n        // Otherwise it's disjoint, so we ignore it.\n        return [[subject]]\n        break;\n      case \"subtractA\":\n        // If A is inside of B, it's a hole.\n        if (sPoints.first.type == \"in\") {\n          return [[clipper, subject]];\n        }\n        if (cPoints.first.type == \"in\") {\n          return [];\n        }\n        // Otherwise it's disjoint, so we ignore it.\n        return [[clipper]];\n        break;\n    }\n  }\n\n  // All points are degenerate. The shapes may be spatially equal.\n  // The intersect === 1 is a dumb hack for certain cases where (probably because of\n  // floating point errors) a single point of a polygon we generated is touching\n  // an edge. This is probably a sign of a bigger issue in intersection detection,\n  // but we'll wait and see how that goes\n  if (totalS == sPoints.count('degenerate', true) || sPoints.count(\"intersect\", true) == 1) {\n    switch (mode) {\n      case \"subtractA\":\n        // If all points in the clip are also degenerate, these shapes\n        // are equal.\n        if (totalC == cPoints.count('degenerate', true)) {\n          return [];\n        }\n        return [[clipper]];\n        break;\n      case \"subtractB\":\n        // If all points in the clip are also degenerate, these shapes\n        // are equal.\n        if (totalC == cPoints.count('degenerate', true)) {\n          return [];\n        }\n        return [[subject]];\n        break;\n      default:\n        return [[subject]];\n    }\n  }\n}\n\n\n/**\n * Builds the list of Polygon(s) representing the desired overlap of\n * the subject/clipper.\n *\n * @param  {[type]} sPoints [description]\n * @return {[type]}         [description]\n */\nfunction buildPolygons(sPoints, s_forward, c_forward) {\n  var curr = sPoints.first;\n  var polylist = [];\n  var onclip = false;\n  var endir = 'next';\n  var exdir = 'prev';\n\n  while (curr = sPoints.firstIntersect()) {\n    var poly = [[curr.x, curr.y]];\n\n    do {\n      if (onclip) {\n        endir = c_forward ? 'next' : 'prev';\n        exdir = c_forward ? 'prev' : 'next';\n      } else {\n        endir = s_forward ? 'next' : 'prev';\n        exdir = s_forward ? 'prev' : 'next';\n      }\n\n      curr.checked = true;\n      if (curr.neighbor) {\n        curr.neighbor.checked = true;\n      }\n\n      if (curr.entry) {\n        do {\n            curr = curr[endir];\n            poly.push([curr.x, curr.y]);\n        } while (!curr.intersect);\n      } else {\n        do {\n          curr = curr[exdir];\n          poly.push([curr.x, curr.y]);\n        } while (!curr.intersect);\n      }\n\n      // Jump to the other list\n      curr = curr.neighbor;\n      onclip = !onclip;\n\n    } while (!curr.checked);\n\n    if (!util.pointsEqual(poly[0], poly[poly.length - 1])) {\n      poly.push(poly[0]);\n    } else if (poly.length < 4) {\n      continue;\n    }\n    polylist.push({geom: poly, is_hole: false})\n  }\n\n  // Generate a graph of which polygons own which other polygons (detect holes)\n  var result = [];\n  var graph = {};\n  for (var i = 0; i < polylist.length; i++) {\n    if (!graph[i]) { graph[i] = []; }\n\n    for (var j = i+1; j < polylist.length; j++) {\n      // Because we just generated the intersections, we know that\n      // none of these results can intersect eachother, so we only need to\n      // run PIP on a single point of each poly.\n      if (pip(polylist[j].geom[0], polylist[i].geom)) {\n        polylist[j].is_hole = true;\n        graph[i].push(j);\n      }\n    }\n  }\n\n  // Construct polys with their holes\n  for (var key in graph) {\n    if (polylist[key].is_hole) {\n      continue;\n    }\n    var poly = [polylist[key].geom];\n    graph[key].forEach(function (idx) {\n      poly.push(polylist[idx].geom);\n    });\n    result.push(poly);\n  }\n  return result;\n}\n\n/**\n * Builds vertex lists for the subject and clipper. Essentially\n * the way this will work is that it will detect intersections by\n * comparing each pair of lines between the subject / clipper, then\n * injecting intersection vertices (marked by the \"intersects\" property)\n * in the appropriate spots in each coordinate list.\n *\n * Once this is complete, our subject and clipper coordinate lists will\n * each contain, in traversable order, every vertex, including ones for\n * each point where the other polygon intersected.\n *\n * @param  {[type]} sPoints [description]\n * @param  {[type]} cPoints [description]\n * @return {[type]}         [description]\n */\nfunction buildIntersectionLists(sPoints, cPoints, sPoly, cPoly) {\n  var sCurr = sPoints.first;\n\n  do {\n    setPointRelativeLocation(sCurr, cPoly)\n    var cCurr = cPoints.first;\n    if (!sCurr.intersect) {\n      do {\n        setPointRelativeLocation(cCurr, sPoly)\n        if (!cCurr.intersect) {\n          var sEnd = sPoints.nextNonIntersect(sCurr.next);\n          var cEnd = cPoints.nextNonIntersect(cCurr.next);\n          var intersect = lineIntersects(sCurr, sEnd, cCurr, cEnd);\n\n          if (intersect) {\n            cCurr = handleIntersection(sPoints, cPoints, sCurr, sEnd, cCurr, cEnd, intersect);\n          }\n        }\n\n        cCurr = cCurr.next;\n      } while (cCurr !== cPoints.first);\n    }\n\n    sCurr = sCurr.next;\n  } while (sCurr !== sPoints.first);\n}\n\n/**\n * Loop back through, ensuring that all degenerate vertices\n * are marked as intersections.\n *\n * @param  {Ring} points [description]\n * @return {[type]}        [description]\n */\nfunction markDegensAsIntersect(points) {\n  var curr = points.first;\n\n  do {\n    if (curr.degenerate) {\n      curr.intersect = true;\n      curr.neighbor.intersect = true;\n    }\n    curr = curr.next\n  } while (curr != points.first)\n}\n\n/**\n * Handle inserting / replacing points appropriately for\n * a found intersection\n *\n * @param  {Ring}   sPoints   Subject Ring\n * @param  {Ring}   cPoints   Clip Ring\n * @param  {Vertex} sCurr     Start of the Subject line\n * @param  {Vertex} sEnd      End of the Subject line\n * @param  {Vertex} cCurr     Start of the Clip line\n * @param  {Vertex} cEnd      End of the Clip line\n * @param  {Object} intersect Object representing an intersection\n * @return {[type]}           [description]\n */\nfunction handleIntersection(sPoints, cPoints, sCurr, sEnd, cCurr, cEnd, intersect) {\n  var sPt, cPt;\n  var s_between = 0 < intersect.alphaA && intersect.alphaA < 1;\n  var c_between = 0 < intersect.alphaB && intersect.alphaB < 1;\n\n  if (s_between && c_between) {\n    sPt = new Vertex(intersect.x, intersect.y, intersect.alphaA, true);\n    cPt = new Vertex(intersect.x, intersect.y, intersect.alphaB, true);\n    sPoints.insert(sPt, sCurr, sEnd);\n    cPoints.insert(cPt, cCurr, cEnd);\n  } else {\n    // Handle various degeneracy cases for the subject point\n    if (s_between) {\n      sPt = new Vertex(intersect.x, intersect.y, intersect.alphaA, true, true);\n      sPoints.insert(sPt, sCurr, sPoints.nextNonIntersect(sCurr.next));\n    } else if (intersect.alphaA == 0) {\n      sCurr.intersect = true;\n      sCurr.degenerate = true;\n      sCurr.alpha = intersect.alphaA;\n      sPt = sCurr;\n    } else if (intersect.alphaA == 1) {\n      // End points get marked as degenerate but don't get marked as intersects.\n      // This allows us to catch them later, and still use them for generating\n      // lines to test against the other polygon\n      sEnd.intersect = false;\n      sEnd.degenerate = true;\n      sEnd.alpha = intersect.alphaA;\n      sPt = sEnd;\n    }\n\n    // Handle various degeneracy cases for the clip point\n    if (c_between) {\n      cPt = new Vertex(intersect.x, intersect.y, intersect.alphaB, true, true);\n      cPoints.insert(cPt, cCurr, cPoints.nextNonIntersect(cCurr.next));\n    } else if (intersect.alphaB == 0) {\n      cCurr.intersect = true;\n      cCurr.degenerate = true;\n      cCurr.alpha = intersect.alphaB;\n      cPt = cCurr;\n    } else if (intersect.alphaB == 1) {\n      // End points get marked as degenerate but don't get marked as intersects.\n      // This allows us to catch them later, and still use them for generating\n      // lines to test against the other polygon\n      cEnd.intersect = false;\n      cEnd.degenerate = true;\n      cEnd.alpha = intersect.alphaB;\n      cPt = cEnd;\n      if (cCurr.next != cPoints.first) {\n        cCurr = cCurr.next;\n      }\n    }\n  }\n\n  // Neighbors are used to jump back and forth between the lists\n  if (sPt && cPt) {\n    sPt.neighbor = cPt;\n    cPt.neighbor = sPt;\n    // Intersections are always \"on\" a line\n    sPt.type = \"on\";\n    cPt.type = \"on\";\n  }\n  return cCurr;\n}\n\n/**\n * Set a point in or out compared to the other polygon:\n * - if it's a subject point, compare to the clip polygon,\n * - if it's a clip point, compare to the subject polygon\n *\n * @param {Vertex}  pt   Point to check against the poly\n * @param {Polygon} poly Check if pt is within this poly\n */\nfunction setPointRelativeLocation(pt, poly) {\n  if (!pt.type) {\n    if (pip([pt.x, pt.y], poly)) {\n      pt.type = \"in\";\n    } else {\n      pt.type = \"out\";\n    }\n  }\n}\n\n/**\n * Handle setting entry/exit flags for each intersection. This is\n * where a large part of degeneracy handling happens - the original\n * GH algorithm uses very simple entry/exit handling, which won't work\n * for our degenerate cases.\n *\n * http://arxiv-web3.library.cornell.edu/pdf/1211.3376v1.pdf\n *\n * @param {Ring}    sPoints The subject polygon's vertices\n */\nfunction setEntryExit(sPoints) {\n  var first = sPoints.first;\n  var curr = first;\n\n  do {\n    if (curr.intersect && curr.neighbor) {\n      handleEnEx(curr);\n      handleEnEx(curr.neighbor);\n\n      // If this and the neighbor share the same entry / exit flag values\n      // we need to throw them out and relabel\n      switch (curr.entryPair()) {\n        case \"en/en\":\n          curr.remove = true;\n          curr.type = \"in\";\n          curr.intersect = false;\n          curr.neighbor.intersect = false;\n          break;\n        case \"ex/ex\":\n          curr.remove = true;\n          curr.type = \"out\";\n          curr.intersect = false;\n          curr.neighbor.intersect = false;\n          break;\n      }\n    }\n\n    curr = curr.next;\n  } while (curr != first)\n}\n\n/**\n * Handles deciding the entry / exit flag setting for a given point.\n * This is probably where most of the things could be wrong\n *\n * @param  {Vertex} curr The vertex to flag\n */\nfunction handleEnEx(curr) {\n  var cp = curr.pairing();\n  switch (cp) {\n      case \"in/out\":\n      case \"on/out\":\n      case \"in/on\":\n        curr.entry = false;\n        break;\n      case \"out/in\":\n      case \"on/in\":\n      case \"out/on\":\n        curr.entry = true;\n        break;\n      case \"out/out\":\n      case \"in/in\":\n      case \"on/on\":\n        var np = curr.neighbor.pairing();\n        if (np == \"out/out\" || np == \"in/in\" || np == \"on/on\" || (cp == \"on/on\" && np == \"on/out\")) {\n          curr.remove = true;\n          curr.neighbor.remove = true;\n          curr.neighbor.intersect = false;\n          curr.intersect = false;\n        } else {\n          handleEnEx(curr.neighbor);\n          curr.entry = !curr.neighbor.entry;\n        }\n        break;\n      default:\n        // This shouldn't ever happen - It's here to confirm nothing stupid is happening.\n        console.error(\"UNKNOWN TYPE\", curr.pairing())\n    }\n}\n\n\n/**\n * Take two lines (each represented by the respective\n * start and end), and tells you where they intersect,\n * as well as the intersection alphas\n *\n * @param  {Vertex} start1 [description]\n * @param  {Vertex} end1   [description]\n * @param  {Vertex} start2 [description]\n * @param  {Vertex} end2   [description]\n * @return {[type]}        [description]\n */\nfunction lineIntersects(start1, end1, start2, end2) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, numerator1, numerator2, result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false,\n    alphaA: null,\n    alphaB: null,\n  };\n  denominator = ((end2.y - start2.y) * (end1.x - start1.x)) - ((end2.x - start2.x) * (end1.y - start1.y));\n  if (denominator == 0) {\n    if (start1.equals(start2)) {\n      result.x = start1.x\n      result.y = start1.y\n      result.alphaA = 0;\n      result.alphaB = 0;\n      return result;\n    }\n    return false;\n  }\n\n  a = start1.y - start2.y;\n  b = start1.x - start2.x;\n  numerator1 = ((end2.x - start2.x) * a) - ((end2.y - start2.y) * b);\n  numerator2 = ((end1.x - start1.x) * a) - ((end1.y - start1.y) * b);\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  // if we cast these lines infinitely in both directions, they intersect here:\n  result.x = start1.x + (a * (end1.x - start1.x));\n  result.y = start1.y + (a * (end1.y - start1.y));\n  result.alphaA = a;\n  result.alphaB = b;\n\n  // TODO: any better way to handle this?\n  if (result.alphaA > 0.99999999999999) {\n    result.alphaA = 1;\n  }\n  if (result.alphaB > 0.99999999999999) {\n    result.alphaB = 1;\n  }\n  if (result.alphaA < 0.00000000000001) {\n    result.alphaA = 0;\n  }\n  if (result.alphaB < 0.00000000000001) {\n    result.alphaB = 0;\n  }\n\n  // if line1 is a segment and line2 is infinite, they intersect if:\n  if (0 <= a && a <= 1) {\n    result.onLine1 = true;\n  }\n  // if line2 is a segment and line1 is infinite, they intersect if:\n  if (0 <= b && b <= 1) {\n    result.onLine2 = true;\n  }\n  // if line1 and line2 are segments, they intersect if both of the above are true\n  if(result.onLine1 && result.onLine2){\n    return result;\n  }\n  else {\n    return false;\n  }\n}\n\n\n/**\n * Utility method for logging points\n *\n * @param  {[type]} sPoints [description]\n * @param  {[type]} cPoints [description]\n * @return {[type]}         [description]\n */\nfunction logPoints(sPoints, cPoints) {\n  console.log(\"POINTS\")\n  console.log(\"-----------------\")\n  var curr = sPoints.first\n  do {\n    curr.log();\n    curr = curr.next\n  } while (curr != sPoints.first)\n  console.log(\"-----------------\")\n  if (!cPoints) return;\n  var curr = cPoints.first\n  do {\n    curr.log();\n    curr = curr.next\n  } while (curr != cPoints.first)\n}\n\n/**\n * Utility method for logging intersecions and degenerate points\n *\n * @param  {[type]} sPoints [description]\n * @return {[type]}         [description]\n */\nfunction logIntersections(sPoints) {\n  console.log(\"-------------------\")\n  console.log(\"INTERSECTION LIST: \")\n  console.log(\"-------------------\")\n  var curr = sPoints.first\n  do {\n    if (curr.intersect || curr.degenerate) {\n      curr.log()\n    }\n    curr = curr.next\n  } while (curr != sPoints.first)\n  console.log(\"\")\n}\n\n\n",
    "var ghClipping = require('./greiner-hormann');\nvar union = require('./union');\nvar utils = require('./util');\nvar subtract = require('./subtract');\n\nmodule.exports = function(subject, clipper) {\n  var subject = utils.clone(subject);\n  var clipper = utils.clone(clipper);\n  var s_hulls = utils.outerHulls(subject);\n  var c_hulls = utils.outerHulls(clipper);\n  var holes = utils.holes(subject).concat(utils.holes(clipper));\n  var result = [];\n\n  for (var i = 0; i < s_hulls.length; i++) {\n    for (var j = 0; j < c_hulls.length; j++) {\n      var test = ghClipping(s_hulls[i], c_hulls[j], true, true);\n      if (Array.isArray(test)) {\n        result = result.concat(test);\n      }\n    }\n  }\n\n  // Union all the holes then subtract them rom the result\n  if (holes.length > 0) {\n    var holeUnion = union(holes);\n\n    return subtract(result, utils.outerHulls(holeUnion));\n  }\n\n  return result;\n}\n",
    "var Vertex = require('./vertex');\nvar clockwise = require('turf-is-clockwise');\n\n/**\n * Ring is a circular doubly-linked list; Every node\n * has a next and a prev, even if it's the only node in the list.\n *\n * This supports some search methods that need to wrap back to the start of the list.\n */\nfunction Ring () {\n    this.first = null;\n}\n\nRing.prototype.count = function(countkey, countval) {\n    var curr = this.first;\n    var count = 0;\n    while (true) {\n        if (countkey) {\n            if (curr[countkey] === countval) {\n                count++;\n            }\n        } else {\n            count++;\n        }\n        curr = curr.next;\n\n        if (curr == this.first) {\n            break;\n        }\n    }\n    return count;\n}\n\n\n/**\n * Takes an array of coordinates and constructs a Ring\n *\n * @param  {array} coordinates   the array of coordinates to convert to a Ring\n * @return {Ring}\n */\nRing.fromArray = function(coordinates) {\n    var ring = new Ring()\n\n    if (!clockwise(coordinates)) {\n        coordinates = coordinates.reverse();\n    }\n\n    for (var i = 0; i < (coordinates.length - 1); i++) {\n        var elem = coordinates[i];\n        ring.push(new Vertex(elem[0], elem[1]));\n    }\n\n    return ring;\n}\n\n/**\n * Push a vertex into the ring's list. This\n * just updates pointers to put the point at\n * the end of the list\n *\n * @param  {Vertex} vertex the vertex to push\n */\nRing.prototype.push = function(vertex) {\n    if (!this.first) {\n        this.first = vertex;\n        this.first.prev = vertex;\n        this.first.next = vertex;\n    } else {\n        next = this.first;\n        prev = next.prev;\n        next.prev = vertex;\n        vertex.next = next;\n        vertex.prev = prev;\n        prev.next = vertex;\n    }\n}\n\n/**\n * Insert a vertex between specific vertices\n *\n * If there are intersection points, inbetween\n * start and end, the new vertex is inserted\n * based on it's alpha value\n *\n * @param  {Vertex} vertex the vertex to insert\n * @param  {Vertex} start  the \"leftmost\" vertex this point could be inserted next to\n * @param  {Vertex} end    the \"rightmost\" vertex this could could be inserted next to\n */\nRing.prototype.insert = function(vertex, start, end) {\n    var curr = start.next;\n\n    while (curr != end && curr.alpha < vertex.alpha) {\n        curr = curr.next;\n    }\n\n    // Insert just before the \"curr\" value\n    vertex.next = curr;\n    prev = curr.prev;\n    vertex.prev = prev;\n    prev.next = vertex;\n    curr.prev = vertex;\n}\n\n/**\n * Start at the start vertex, and get the next\n * point that isn't an intersection\n *\n * @param  {Vertex} start the vertex to start searching at\n * @return {Vertex} the next non-intersect\n */\nRing.prototype.nextNonIntersect = function (start) {\n    var curr = start;\n    while (curr.intersect && curr != this.first) {\n        curr = curr.next\n    }\n    return curr;\n}\n\n/**\n * Returns the first unchecked intersection in the list\n *\n * @return {Vertex|bool}\n */\nRing.prototype.firstIntersect = function () {\n    var curr =  this.first;\n\n    while (true) {\n        if (curr.intersect && !curr.checked) {\n            return curr;\n        }\n\n        curr = curr.next;\n\n        if (curr == this.first) {\n            break;\n        }\n    }\n    return false;\n}\n\n/**\n * Converts the Ring into an array\n *\n * @return {array} array representation of the ring\n */\nRing.prototype.toArray = function () {\n    var curr = this.first;\n    var points = [];\n\n    do {\n        points.push([curr.x, curr.y]);\n        curr = curr.next;\n    } while (curr != this.first);\n\n    return points;\n}\n\nmodule.exports = Ring;\n",
    "var util = require('./util');\nvar ghClipping = require('./greiner-hormann');\n\nfunction intersect(hulls, holes) {\n  var result = [];\n  for (var i = 0; i < hulls.length; i++) {\n    for (var j = 0; j < holes.length; j++) {\n      var test = ghClipping(hulls[i], holes[j], true, true);\n      if (Array.isArray(test)) {\n        result = result.concat(test);\n      }\n    }\n  }\n  return result;1\n}\n\nfunction subtract(subject, clip, skiploop) {\n  skiploop = !!skiploop;\n  subject = util.clone(subject);\n  clip = util.clone(clip);\n\n  var s_hulls = util.outerHulls(subject);\n  var c_hulls = util.outerHulls(clip);\n  var c_holes = util.holes(clip);\n\n  // TODO:\n  // If there are any holes in the subject, subtract those as well\n  // If there are any holes in the clip, which overlap the original\n  // subject, these should be unioned in. This means we'll have to\n  // check polygon within-ness for each clip hole\n\n  // first intersect any holes in clip against the hulls in the subject.\n  // If there are results from these, then these holes overlap the subject,\n  // meaning they (or some part of them) will be saved in the final output as\n  // outer hulls\n  if (c_holes) {\n    var c_holes = intersect(s_hulls, c_holes);\n  }\n\n  if (util.isPolygon(subject)) {\n    subject = [subject];\n  } else {\n    subject = util.wrapToPolygons(subject);\n  }\n\n  for (var i = 0; i < c_hulls.length; i++) {\n    var ilen = subject.length;\n    for (var j = 0; j < subject.length; j++) {\n      var test = ghClipping(subject[j][0], c_hulls[i], false, true);\n      if (test.length == 0) {\n        subject.splice(j, 1);\n        j--;\n        continue;\n      }\n      // Copy the primary hull of the intersect record that\n      // we just clipped against the hull\n      subject[j][0] = test[0][0];\n\n      // Copy in each hole (if there were any) for the primary hull\n      for (var k = 1; k < test[0].length; k++) {\n        subject[j].push(test[0][k]);\n      }\n\n      // If there are any additional polygons in the result,\n      // they were newly created by intersecting this hole.\n      // Push the new polygon (hull and any holes) straight\n      // into the intersect list\n      for (var k = 1; k < test.length; k++) {\n        subject.push(test[k]);\n      }\n    }\n\n    // If the length has changed, this hole created\n    // new intersection polygons, which means it's not a hole\n    // anymore (it crossed the polys, now it's boundary is\n    // part of the new intersection hulls). Therefore, we\n    // remove this hole from the list so it won't be returned.\n    if (ilen != subject.length) {\n      c_hulls.splice(i, 1)\n      i--;\n    }\n  }\n\n  // Union remaining clip-polygon holes if they exist.\n  if (c_holes.length > 0) {\n    subject = subject.concat(util.wrapToPolygons(c_holes));\n  }\n\n  // Re-cut everything against the subject's holes to be\n  // 100% certain they don't change any information in the output\n  var s_holes = util.holes(subject);\n\n  if (s_holes.length > 0 && !skiploop) {\n    return subtract(util.wrapToPolygons(util.outerHulls(subject)), util.wrapToPolygons(s_holes), true)\n  }\n\n  return subject;\n}\n\n\nmodule.exports = subtract;\n",
    "var ghClipping = require('./greiner-hormann');\nvar utils = require('./util');\nvar subtract = require('./subtract');\n\n/**\n * Iteratively join all rings in the passed set.\n *\n * @param  {array} rings An array of polygon rings\n * @return {[type]}       [description]\n */\nfunction unionRings(rings, holes)\n{\n  var step = 0;\n  for (var i = 0; i < rings.length; i++) {\n    for (var j = i+1; j < rings.length; j++) {\n      if (i == j) {\n        continue;\n      }\n      var test = ghClipping(rings[i], rings[j], false, false);\n\n      // If the length is 1, we joined the two areas, so replace\n      // rings[i] with the new shape, and remove rings[j]\n      // Then reset the j iterator so we can make sure that none of\n      // the previous rings will now overlap the new rings[i]\n      if (test.length == 1) {\n        rings[i] = test[0][0];\n        rings.splice(j, 1);\n        j = i;\n\n        // If there are holes, copy them into the holes array.\n        if (test[0].length > 1) {\n          test[0].forEach(function(elem, idx) {\n            if (idx != 0) {\n              holes.push(elem);\n            }\n          });\n        }\n      }\n    }\n  }\n  return rings;\n}\n\n/**\n * Method for subtracting hulls from holes. This is used\n * before calculating the union to ensure correctly shaped\n * holes in all of the input polygons\n *\n * @param  {[type]} coords [description]\n * @param  {[type]} j      [description]\n * @param  {[type]} i      [description]\n * @return {[type]}        [description]\n */\nfunction clipHoles(coords, hull_idx, hole_idx) {\n  var hulls = utils.outerHulls(coords[hull_idx]);\n  var holes = utils.holes(coords[hole_idx]);\n\n  if (holes.length > 0) {\n    var newholes = subtract(utils.wrapToPolygons(holes), hulls);\n    coords[hole_idx].splice(1);\n    coords[hole_idx] = coords[hole_idx].concat(utils.outerHulls(newholes));\n  }\n}\n\n// TODO: make this support polys + holes. Right now\n// it takes an array of rings, not array of polys.\n//\n// TODO: think about the function signature here? Should it be\n// traditional \"union A + B\", or is passing a set of things to union more useful\n//\n// TODO: think about using the approach here: http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html\n// to make things faster for complex / very degenerate sets\nmodule.exports = function(coords, coords2) {\n  if (typeof coords2 != 'undefined' && coords2 != null) {\n    // TODO: make this more robust. This will fail in some cases\n    if (!utils.isMultiPolygon(coords)) {\n      coords = [coords];\n    }\n    if (!utils.isMultiPolygon(coords2)) {\n      coords2 = [coords2];\n    }\n    coords = coords.concat(coords2)\n  }\n\n  coords = utils.clone(coords);\n  // Preprocess the holes. This covers cases such as the one here:\n  // https://github.com/tchannel/greiner-hormann/issues/7\n  for (var i = 0; i < coords.length; i++) {\n    for (var j = i+1; j < coords.length; j++) {\n      clipHoles(coords, j, i);\n      clipHoles(coords, i, j);\n    }\n  }\n\n\n\n\n  var hulls = utils.outerHulls(coords);\n  var holes = utils.holes(coords);\n  // Union all hulls. Holes is passed in, to handle cases where the union\n  // generates new holes (they'll be pushed into the holes array)\n  hulls = utils.wrapToPolygons(unionRings(hulls, holes));\n\n  // Union all holes - If holes overlap, they should be joined\n  if (holes.length > 0) {\n    holes = unionRings(holes);\n    holes = utils.wrapToPolygons(holes);\n    // Subtract all rings from the unioned set\n    return subtract(hulls, holes);\n  }\n\n  return hulls;\n}\n",
    "if (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n\n// deep clone an array of coordinates / polygons\nexports.clone = function(array) {\n  var new_arr = [];\n  for (var i = 0; i < array.length; i++) {\n    if (Array.isArray(array[i])){\n      new_arr.push(exports.clone(array[i]).slice());\n    } else {\n      new_arr.push(array[i]);\n    }\n  }\n  return new_arr;\n}\n\n// Wrap an array of geometries to an array of polygons\nexports.wrapToPolygons = function(array) {\n  var wrapped = [];\n  for(var i = 0; i < array.length; i++) {\n    if (exports.isRing(array[i])) {\n      wrapped.push([array[i]]);\n    } else if (exports.isMultiPolygon(array[i])) {\n      wrapped.concat(array[i]);\n    } else if (exports.isPolygon(array[i])) {\n      wrapped.push(array[i]);\n    }\n  }\n  return wrapped;\n}\n\n// Unwrap polygons to an array of rings\nexports.unwrap = function(array) {\n  var unwrapped = [];\n  for (var i = 0; i < array.length; i++) {\n    for (var j = 0; j < array[i].length; j++) {\n      unwrapped.push(array[i][j]);\n    }\n  }\n}\n\n\n/**\n * Count array depth (used to check for geom type)\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.depth = function(collection) {\n  function depth(collection, num) {\n    if (Array.isArray(collection)) {\n      return depth(collection[0], num+1);\n    }\n    return num;\n  }\n\n  return depth(collection, 0);\n}\n\n\nexports.isMultiPolygon = function(poly) {\n  if (exports.depth(poly) == 4) {\n    return true;\n  }\n  return false;\n}\n\n\nexports.isPolygon = function(poly) {\n  if (exports.depth(poly) == 3) {\n    return true;\n  }\n  return false;\n}\n\nexports.isRing = function(poly) {\n  if(exports.depth(poly) == 2) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Takes a list of polygons / multipolygons and returns only the outer hulls\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.outerHulls = function(collection) {\n  var hulls = [];\n\n  if (exports.isPolygon(collection)) {\n    return [collection[0]];\n  }\n\n  for (var i = 0; i < collection.length; i++) {\n    if (exports.isMultiPolygon(collection[i])) {\n      // Each polygon\n      for (var j = 0; j < collection[i].length; j++) {\n        hulls.push(collection[i][j][0]);\n      }\n    } else if (exports.isPolygon(collection[i])) {\n      hulls.push(collection[i][0]);\n    } else if (exports.isRing(collection[i])) {\n      hulls.push(collection[i]);\n    }\n  }\n\n  return hulls;\n}\n\n/**\n * Takes a list of multipolygons / polygons and returns only the holes\n *\n * @param  {[type]} collection [description]\n * @return {[type]}            [description]\n */\nexports.holes = function(collection) {\n  var holes = [];\n\n  if (exports.isPolygon(collection)) {\n    return collection.slice(1)\n  }\n\n  for (var i = 0; i < collection.length; i++) {\n    if (exports.isMultiPolygon(collection[i])) {\n      // Each polygon\n      for (var j = 0; j < collection[i].length; j++) {\n        for (var k = 1; k < collection[i][j].length; k++) {\n          holes.push(collection[i][j][k]);\n        }\n      }\n    } else if (exports.isPolygon(collection[i])) {\n      for (var j = 1; j < collection[i].length; j++) {\n        holes.push(collection[i][j]);\n      }\n    }\n  }\n\n  return holes;\n}\n\n\nexports.pointsEqual = function (pt1, pt2) {\n  if (pt1[0] == pt2[0] && pt1[1] == pt2[1]) {\n    return true;\n  }\n  return false;\n}\n",
    "function Vertex (x, y, alpha, intersect, degenerate) {\n    this.x = x;\n    this.y = y;\n    this.alpha = alpha || 0.0;\n    this.intersect = intersect || false;\n    this.entry = true; // Set to true by default, for degeneracy handling\n    this.checked = false;\n    this.degenerate = degenerate || false;\n    this.neighbor = null;\n    this.next = null;\n    this.prev = null;\n    this.type = null; // can be \"in\", \"out\", \"on\"\n    this.remove = false;\n}\n\n/**\n * Returns a string representing the types of the previous and next vertices.\n * For example, if the prev vertex had type \"in\" and the next had type \"out\",\n * the pairing would be \"in/out\". This matches the way pairs are referenced in\n * the Greiner-Hormann Degeneracy paper.\n *\n * @return {String} the pairing description\n */\nVertex.prototype.pairing = function () {\n    return this.prev.type + \"/\" + this.next.type;\n}\n\n/**\n * Returns a string representing the entry / exit flag of this vertex and it's neighbor\n * For example, if the current vertex was flagged entry = true and it's neighbor was flagged\n * entry = false, the entryPair would be \"en/ex\" (short for \"entry/exit\"). This matches the\n * way flags are referenced in the Greiner-Hormann Degeneracy paper.\n *\n * @return {String} the entry/exit pair string\n */\nVertex.prototype.entryPair = function() {\n    var entry = this.entry ? \"en\" : \"ex\";\n    var nEntry = this.neighbor.entry ? \"en\" : \"ex\";\n\n    return entry+\"/\"+nEntry;\n}\n\n/**\n * Determine if this vertex is equal to another\n *\n * @param  {Vertex} other the vertex to compare with\n * @return {bool}   whether or not the vertices are equal\n */\nVertex.prototype.equals = function(other) {\n    if (this.x == other.x && this.y == other.y) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Utility method to log the vertex, only for debugging\n */\nVertex.prototype.log = function() {\n  console.log(\n      \"INTERSECT: \"+ (this.intersect ? \"Yes\" : \"No \")\n      +\" ENTRY: \"+(this.entry ? \"Yes\": \"No \")\n      +\" DEGEN: \"+(this.degenerate ? \"Yes\": \"No \")\n      +\" TYPE: \"+String(this.prev.type+\" \").slice(0, 3)\n          +\" / \"+String(this.type+\" \").slice(0, 3)\n          +\" / \"+String(this.next.type+\" \").slice(0, 3)\n      +\" ALPHA: \"+ this.alpha.toPrecision(3)\n      +\" REMOVE: \"+ (this.remove ? \"Yes\": \"No\") + \" \"\n      +this.x + \", \"+this.y\n    );\n};\n\n\nmodule.exports = Vertex;\n",
    "module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n",
    "module.exports = function(ring){\n  var sum = 0;\n  var i = 1;\n  var len = ring.length;\n  var prev,cur;\n  while(i<len){\n    prev = cur||ring[0];\n    cur = ring[i];\n    sum += ((cur[0]-prev[0])*(cur[1]+prev[1]));\n    i++;\n  }\n  return sum > 0;\n}"
  ]
}